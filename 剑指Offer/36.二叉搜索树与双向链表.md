# 36.二叉搜索树与双向链表

[**JZ36** 二叉搜索树与双向链表](https://chat.openai.com/c/86c0a9eb-3794-4a93-9a52-2bd1ef27a46f)

`medium`

**<font color=red>利用中序遍历 二叉树的排序性质</font>**

## 题目描述

> 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示
>
> ![img](https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2)
>
> 数据范围：输入二叉树的节点数 0≤�≤10000≤*n*≤1000，二叉树中每个节点的值 0≤���≤10000≤*v**a**l*≤1000
> 要求：空间复杂度�(1)*O*(1)（即在原树上操作），时间复杂度 �(�)*O*(*n*)
>
> 注意:
>
> 1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继
> 2.返回链表中的第一个节点的指针
> 3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构
>
> 4.你不用输出双向链表，程序会根据你的返回值自动打印输出
>
> ### 输入描述：
>
> 二叉树的根节点
>
> ### 返回值描述：
>
> 双向链表的其中一个头节点。
>
> ## 示例1
>
> 输入：
>
> ```
> {10,6,14,4,8,12,16}
> ```
>
> 复制
>
> 返回值：
>
> ```
> From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4;
> ```
>
> 复制
>
> 说明：
>
> ```
> 输入题面图中二叉树，输出的时候将双向链表的头节点返回即可。     
> ```
>
> ## 示例2
>
> 输入：
>
> ```
> {5,4,#,3,#,2,#,1}
> ```
>
> 复制
>
> 返回值：
>
> ```
> From left to right are:1,2,3,4,5;From right to left are:5,4,3,2,1;
> ```

## Core

- 利用中序遍历 二叉树的排序性质



## Code

O(n), O(1)

```swift
/**
 * public class TreeNode {
 *   public var val: Int
 *   public var left: TreeNode?
 *   public var right: TreeNode?
 *   public init(_ val: Int=0, _ left: TreeNode?=nil, _ right: TreeNode?=nil) {
 *     self.val = val
 *     self.left = left
 *     self.right = right
 *   }
 */
public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param pRootOfTree TreeNode类 
     * @return TreeNode类
     */
    
    var first: TreeNode?
    var last: TreeNode?
    func Convert ( _ pRootOfTree: TreeNode?) -> TreeNode? {
        // write code here
        // 初始化节点
        first = nil
        last = nil
        // 中序遍历，将二叉搜索树转换为双向链表
        convertHelper(pRootOfTree)
        return first
    }
    func convertHelper(_ node: TreeNode?) {
        guard let node = node else {
            return 
        }
        // 左子树
        convertHelper(node.left)
        // 如果尾节点不为空，将当前节点连接到尾节点
        if last != nil {
            last?.right = node
            node.left = last
        } else {
            // 如果尾节点为空，表示当前节点是双向链表的第一个节点
            first = node
        }
        // 更新尾节点为当前节点
        last = node
        // 右子树
        convertHelper(node.right)
    }
}
```

