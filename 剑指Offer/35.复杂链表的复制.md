# 35.复杂链表的复制

[138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

`medium`

**<font color=red>修改原始链表再拆分</font>**

## 题目描述

> 给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。
>
> 构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。
>
> 例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。
>
> 返回复制链表的头节点。
>
> 用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：
>
> - `val`：一个表示 `Node.val` 的整数。
> - `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。
>
> 你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)
>
> ```
> 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
> 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)
>
> ```
> 输入：head = [[1,1],[2,1]]
> 输出：[[1,1],[2,1]]
> ```
>
> **示例 3：**
>
> **![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)**
>
> ```
> 输入：head = [[3,null],[3,0],[3,null]]
> 输出：[[3,null],[3,0],[3,null]]
> ```

## Core

- 用哈希表来记录：用空间换时间

- better：

  通过修改原始链表来实现深度拷贝，而不需要额外的空间。以下是一种不使用额外空间的方法，但需要对原链表进行一些修改：

  1. 在每个节点后插入一个拷贝节点，并将其连接到原节点的 `next` 指针。
  2. 在第二次遍历时，将拷贝节点的 `random` 指针设置为正确的节点，即 `original.random.next`。
  3. 将链表分割成原始链表和拷贝链表，然后将拷贝链表从原始链表中提取出来。



## Code

O(n),  O(n)

```swift
/**
 * Definition for a Node.
 * public class Node {
 *     public var val: Int
 *     public var next: Node?
 *     public var random: Node?
 *     public init(_ val: Int) {
 *         self.val = val
 *         self.next = nil
 *    	   self.random = nil
 *     }
 * }
 */

class Solution {
    func copyRandomList(_ head: Node?) -> Node? {
        if head == nil {
            return nil
        }
        
        // 第一遍遍历：在每个节点后插入拷贝节点
        var current = head
        while current != nil {
            let copyNode = Node(current!.val)
            copyNode.next = current!.next
            current!.next = copyNode
            current = copyNode.next
        }
        
        // 第二遍遍历：设置拷贝节点的 random 指针
        current = head
        while current != nil {
            if let random = current!.random {
                current!.next!.random = random.next
            }
            current = current!.next!.next
        }
        
        // 第三遍遍历：将拷贝链表从原链表中分离出来
        current = head
        let newHead = current!.next
        var newCurrent = newHead
        while current != nil {
            current!.next = current!.next!.next
            current = current!.next
            if current != nil {
                newCurrent!.next = current!.next
                newCurrent = newCurrent!.next
            }
        }
        return newHead
    }   
}
```

