# 60.n个骰子的点数

[LCR 185. 统计结果概率](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/)

`medium`

**<font color=red>动态规划，画图</font>**

## 题目描述

> 你选择掷出 `num` 个色子，请返回所有点数总和的概率。
>
> 你需要用一个浮点数数组返回答案，其中第 `i` 个元素代表这 `num` 个骰子所能掷出的点数集合中第 `i` 小的那个的概率。
>
>  
>
> **示例 1：**
>
> ```
> 输入：num = 3
> 输出：[0.00463,0.01389,0.02778,0.04630,0.06944,0.09722,0.11574,0.12500,0.12500,0.11574,0.09722,0.06944,0.04630,0.02778,0.01389,0.00463]
> ```
>
> **示例 2：**
>
> ```
> 输入：num = 5
> 输出:[0.00013,0.00064,0.00193,0.00450,0.00900,0.01620,0.02636,0.03922,0.05401,0.06944,0.08372,0.09452,0.10031,0.10031,0.09452,0.08372,0.06944,0.05401,0.03922,0.02636,0.01620,0.00900,0.00450,0.00193,0.00064,0.00013]
> ```
>
>  
>
> **提示：**
>
> - `1 <= num <= 11`

## Core

- 动态规划，画图

## Code

O(n * 6^2), O(n * 6)

```swift
class Solution {
    func statisticsProbability(_ num: Int) -> [Double] {
        var n = num
        var dp = [[Double]](repeating: [Double](repeating: 0, count: 6 * n + 1), count: n + 1)
        // 初始化第一个骰子的情况
        for j in 1 ... 6 {
            dp[1][j] = 1.0 / 6.0
        }
        if n > 1 {
            // 递推计算后续骰子的情况
            for i in 2 ... n {
                for j in i ... 6 * i {
                    for k in 1 ... 6 {
                        if j - k >= i - 1 {
                            dp[i][j] += dp[i - 1][j - k] * 1.0 / 6.0
                        }
                    }
                }
            }
        }
        // 提取结果，即投掷 n 个骰子后各种点数和的概率
        var res = [Double]()
        for j in n ... (6 * n) {
            res.append(dp[n][j])
        }
        return res
    }
}
```

