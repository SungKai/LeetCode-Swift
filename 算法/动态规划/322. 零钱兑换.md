# 322. 零钱兑换

https://leetcode.cn/problems/coin-change/

`medium`

**<font color=red>完全背包，但是要注意不能凑成的问题</font>**

## 题目描述

> 给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。
>
> 计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。
>
> 你可以认为每种硬币的数量是无限的。
>
>  
>
> **示例 1：**
>
> ```
> 输入：coins = [1, 2, 5], amount = 11
> 输出：3 
> 解释：11 = 5 + 5 + 1
> ```
>
> **示例 2：**
>
> ```
> 输入：coins = [2], amount = 3
> 输出：-1
> ```
>
> **示例 3：**
>
> ```
> 输入：coins = [1], amount = 0
> 输出：0
> ```



## Core

- **完全背包，但是要注意不能凑成的问题**
- 关于什么时候用min/max，什么时候 dp[j] += 取决于**题目意思**。
  - 如果是问最多有多少种解法，就是dp[j] += 
  - 但是如果是问最少的情况，用min
- dp[i]表示当总金额为i时，所需硬币的最少个数
- 递推公式：dp[j] = min(dp[j], dp[j - coin] + 1)
- 但是这道题有凑不整，失败的情况，这个时候需要加条件判断，把初始值设置成`Int.max`, dp[0]设置成0，这样如果遍历到如果发现`dp[j - coin]`为`Int.max`，就说明前一个无法凑成，也就说明当前的也无法凑成



## Code

 时间复杂度是 O(amount * n)，其中 amount 表示总金额，n 表示硬币的面额数量。在两层嵌套的循环中，外层循环遍历金额，内层循环遍历硬币的面额。因此，总共进行了 amount * n 次操作。

空间复杂度是 O(amount)，因为我们使用了一个长度为 amount + 1 的动态规划数组来存储每个金额所需的最少硬币个数。这个数组的大小与总金额成线性关系。

```swift
class Solution {
    func coinChange(_ coins: [Int], _ amount: Int) -> Int {
        var dp = [Int](repeating: Int.max, count: amount + 1)
        dp[0] = 0

        for coin in coins {
            for j in 0 ... amount {
                if j >= coin, dp[j - coin] != Int.max {
                    dp[j] = min(dp[j], dp[j - coin] + 1)
                }
            }
        }
        if dp[amount] == Int.max {
            return -1
        }
        return dp[amount]
    }
}
```

