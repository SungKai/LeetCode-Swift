# 718. 最长重复子数组

https://leetcode.cn/problems/maximum-length-of-repeated-subarray/

`medium`

**<font color=red>子序列问题</font>**

## 题目描述

> 给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
> 输出：3
> 解释：长度最长的公共子数组是 [3,2,1] 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
> 输出：5
> ```



## Core

- 子序列问题

- 创建一个二维数组dp，**dp[i] [j]表示nums1前i个元素和nums2前j个元素的最长公共子数组长度**

- 确定递推公式

  根据dp[i] [j]的定义，dp[i][j]的状态只能由dp[i - 1] [j - 1]推导出来。

  即当A[i - 1] 和B[j - 1]相等的时候，dp[i] [j] = dp[i - 1] [j - 1] + 1;



## Code

- 时间复杂度：O(n × m)，n 为A长度，m为B长度
- 空间复杂度：O(n × m)

```swift
class Solution {
    func findLength(_ nums1: [Int], _ nums2: [Int]) -> Int {
        let m = nums1.count
        let n = nums2.count

        // 创建一个二维数组dp，dp[i][j]表示nums1前i个元素和nums2前j个元素的最长公共子数组长度
        var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)
        var res = 0
        for i in 1 ... m {
            for j in 1 ... n {
                if nums1[i - 1] == nums2[j - 1] {
                    dp[i][j] = dp[i - 1][j - 1] + 1
                    res = max(res, dp[i][j])
                }
            }
        }
        return res
    }
}
```

