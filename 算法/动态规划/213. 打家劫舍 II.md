# 213. 打家劫舍 II

https://leetcode.cn/problems/house-robber-ii/

`medium`

**<font color=red>打家劫舍问题，拆分问题</font>**

## 题目描述

> 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [2,3,2]
> 输出：3
> 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,2,3,1]
> 输出：4
> 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
>      偷窃到的最高金额 = 1 + 3 = 4 。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [1,2,3]
> 输出：3
> ```



## Core

- 将问题分成两个子问题：
  1. 偷窃第一个房屋，不偷窃最后一个房屋。
  2. 偷窃最后一个房屋，不偷窃第一个房屋。

- 分后就是[198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

## Code

O(n), O(n)

```swift
class Solution {
    func rob(_ nums: [Int]) -> Int {
        let n = nums.count
        if n == 0 {
            return 0
        } else if n == 1 {
            return nums[0]
        } else if n == 2 {
            return max(nums[0], nums[1])
        }
        // 偷窃第一个房屋，不偷窃最后一个房屋
        let dp1 = robHelper(Array(nums[0 ..< n - 1]))
        
        // 偷窃最后一个房屋，不偷窃第一个房屋
        let dp2 = robHelper(Array(nums[1 ..< n]))
        return max(dp1, dp2)
    }
    func robHelper(_ nums: [Int]) -> Int {
        let n = nums.count 
        var dp = [Int](repeating: 0, count: n)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])

        for i in 2 ..< n {
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
        }
        return dp[n - 1]
    }
}
```

