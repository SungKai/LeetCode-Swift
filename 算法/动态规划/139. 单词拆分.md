# 139. 单词拆分

https://leetcode.cn/problems/word-break/

`medium`

**<font color=red>完全背包，题目转化理解</font>**

## 题目描述

> 给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。
>
> **注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
>
>  
>
> **示例 1：**
>
> ```
> 输入: s = "leetcode", wordDict = ["leet", "code"]
> 输出: true
> 解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
> ```
>
> **示例 2：**
>
> ```
> 输入: s = "applepenapple", wordDict = ["apple", "pen"]
> 输出: true
> 解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
>      注意，你可以重复使用字典中的单词。
> ```
>
> **示例 3：**
>
> ```
> 输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
> 输出: false
> ```



## Core

- 单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满

- **dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词**。

- 如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j < i ）。

  所以递推公式是 if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。

## Code

时间复杂度是 O(n^2)，其中 `n` 是字符串的长度，空间复杂度是 O(n)。

```swift
class Solution {
    func wordBreak(_ s: String, _ wordDict: [String]) -> Bool {
        let wordSet = Set(wordDict)  // 将字典中的单词转换为集合，以便快速查找

        let n = s.count
        var dp = [Bool](repeating: false, count: n + 1)
        dp[0] = true

        for i in 1 ... n {
            for j in 0 ..< i {
                let startIndex = s.index(s.startIndex, offsetBy: j)
                let endIndex = s.index(s.startIndex, offsetBy: i)
                let word = String(s[startIndex ..< endIndex])
                if dp[j], wordSet.contains(word) {
                    dp[i] = true
                    break
                }
            }
        }
        return dp[n]
    }
}
```

