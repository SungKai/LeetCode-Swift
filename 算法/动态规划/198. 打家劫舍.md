# 198. 打家劫舍

https://leetcode.cn/problems/house-robber/

`medium`

**<font color=red>打家劫舍问题，取决于前两个房屋偷与否</font>**

## 题目描述

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。
>
>  
>
> **示例 1：**
>
> ```
> 输入：[1,2,3,1]
> 输出：4
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>      偷窃到的最高金额 = 1 + 3 = 4 。
> ```
>
> **示例 2：**
>
> ```
> 输入：[2,7,9,3,1]
> 输出：12
> 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
>      偷窃到的最高金额 = 2 + 9 + 1 = 12 。
> ```



## Core

- 打家劫舍问题，取决于前两个房屋偷与否
- **dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。

- **确定递推公式**

决定dp[i]的因素就是第i房间偷还是不偷。

如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。

如果不偷第i房间，那么dp[i] = dp[i - 1]，即考虑i-1房，（**注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点**）

然后dp[i]取最大值，即**dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])**;



## Code

O(n), O(n)

```swift
class Solution {
    func rob(_ nums: [Int]) -> Int {
        let n = nums.count
        if n <= 0 {
            return 0
        } else if n == 1 {
            return nums[0]
        }
        // 创建一个数组来存储最大金额
        var dp = [Int](repeating: 0, count: n)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])

        // 使用动态规划来计算每个房屋的最大金额
        for i in 2 ..< n {
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
        }
        // 返回最后一个房屋的最大金额
        return dp[n - 1]
    }
}
```

