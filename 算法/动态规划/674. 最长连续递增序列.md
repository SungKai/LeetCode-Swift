# 674. 最长连续递增序列

https://leetcode.cn/problems/longest-continuous-increasing-subsequence/

**<font color=red>子序列问题，连续</font>**

## 题目描述

> 给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。
>
> **连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,3,5,4,7]
> 输出：3
> 解释：最长连续递增序列是 [1,3,5], 长度为3。
> 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [2,2,2,2,2]
> 输出：1
> 解释：最长连续递增序列是 [2], 长度为1。
> ```

## Core

- **dp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]**。

- **确定递推公式**

​		如果 nums[i] > nums[i - 1]，那么以 i 为结尾的连续递增的子序列长度 一定等于 以i - 1为结尾的连续递增的子序列长度 + 1 。

​		即：dp[i] = dp[i - 1] + 1;



## Code

时间复杂度是O(n)，其中n是输入数组`nums`的长度。空间复杂度也是O(n)，因为我们使用了一个长度为n的`dp`数组来存储中间状态。

```swift
class Solution {
    func findLengthOfLCIS(_ nums: [Int]) -> Int {
        let n = nums.count
        if n <= 1 {
            return n
        }

        var dp = [Int](repeating: 1, count: n)
        var res = 1

        for i in 1 ..< n {
            if nums[i] > nums[i - 1] {
                dp[i] = max(dp[i], dp[i - 1] + 1)
            }
            res = max(res, dp[i])
        }
        return res
    }
}
```

