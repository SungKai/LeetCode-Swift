# 516. 最长回文子序列

https://leetcode.cn/problems/longest-palindromic-subsequence/

`medium`

**<font color=red>回文子序列问题</font>**

## 题目描述

> 给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。
>
> 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "bbbab"
> 输出：4
> 解释：一个可能的最长回文子序列为 "bbbb" 。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "cbbd"
> 输出：2
> 解释：一个可能的最长回文子序列为 "bb" 。
> ```

## Core

- 回文子序列问题

- **dp[i] [j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i] [j]**。

  1. 确定递推公式

  在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。

  如果s[i]与s[j]相同，那么dp[i] [j] = dp[i + 1] [j - 1] + 2;

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210127151350563.jpg" alt="516.最长回文子序列" style="zoom: 67%;" /> 

- 如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。

加入s[j]的回文子序列长度为dp[i + 1] [j]。

加入s[i]的回文子序列长度为dp[i] [j - 1]。

那么dp[i] [j]一定是取最大的，即：dp[i] [j] = max(dp[i + 1] [j], dp[i] [j - 1]);

## Code

时间复杂度是O(n^2^)，其中n是字符串`s`的长度。空间复杂度也是O(n^2^)，因为我们使用了一个二维数组来存储中间状态。

```swift
class Solution {
    func longestPalindromeSubseq(_ s: String) -> Int {
        let n = s.count
        if n <= 1 {
            return n
        }
        let sArray = Array(s)
        // 创建一个二维数组dp，dp[i][j]表示s[i...j]之间的最长回文子序列的长度
        var dp = Array(repeating: Array(repeating: 0, count: n), count: n)
        for i in 0 ..< n {
            dp[i][i] = 1
        }

        for len in 2 ... n {
            for i in 0 ..< (n - len + 1) {
                let j = i + len - 1
                if sArray[i] == sArray[j] {
                    dp[i][j] = dp[i + 1][j - 1] + 2
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
                }
            }
        }
        return dp[0][n - 1]
    }
}
```

