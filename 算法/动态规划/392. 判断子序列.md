# 392. 判断子序列

https://leetcode.cn/problems/is-subsequence/

**<font color=red>编辑距离的入门题目</font>**

## 题目描述

> 给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。
>
> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。
>
> **进阶：**
>
> 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？
>
> **致谢：**
>
> 特别感谢 [@pbrother ](https://leetcode.com/pbrother/)添加此问题并且创建所有测试用例。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "abc", t = "ahbgdc"
> 输出：true
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "axc", t = "ahbgdc"
> 输出：false
> ```

## Core

- **编辑距离的入门题目**
- **dp[i] [j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i] [j]**。

- if (s[i - 1] == t[j - 1])
  - t中找到了一个字符在s中也出现了
- if (s[i - 1] != t[j - 1])
  - 相当于t要删除元素，继续匹配

## Code

- 时间复杂度：O(n × m)
- 空间复杂度：O(n × m)

```swift
class Solution {
    func isSubsequence(_ s: String, _ t: String) -> Bool {
        let m = s.count
        let n = t.count
        
        if m == 0 {
            return true
        } else if n == 0 {
            return false
        }

        let sArray = Array(s)
        let tArray = Array(t)

        var dp = Array(repeating: Array(repeating: false, count: n + 1), count: m + 1)
        // 初始化第一行，表示空字符串s是t的子序列
        for j in 0 ... n {
            dp[0][j] = true
        }
        
        for i in 1 ... m {
            for j in 1 ... n {
                if sArray[i - 1] == tArray[j - 1] {
                    dp[i][j] = dp[i - 1][j - 1]
                } else {
                    dp[i][j] = dp[i][j - 1]
                }
            }
        }
        return dp[m][n]
    }
}
```

