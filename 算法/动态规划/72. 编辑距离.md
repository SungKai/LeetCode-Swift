# 72. 编辑距离

https://leetcode.cn/problems/edit-distance/

`hard`

**<font color=red>编辑距离，需要增加字符</font>**

## 题目描述

> 给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。
>
> 你可以对一个单词进行如下三种操作：
>
> - 插入一个字符
> - 删除一个字符
> - 替换一个字符
>
> **示例 1：**
>
> ```
> 输入：word1 = "horse", word2 = "ros"
> 输出：3
> 解释：
> horse -> rorse (将 'h' 替换为 'r')
> rorse -> rose (删除 'r')
> rose -> ros (删除 'e')
> ```
>
> **示例 2：**
>
> ```
> 输入：word1 = "intention", word2 = "execution"
> 输出：5
> 解释：
> intention -> inention (删除 't')
> inention -> enention (将 'i' 替换为 'e')
> enention -> exention (将 'n' 替换为 'x')
> exention -> exection (将 'n' 替换为 'c')
> exection -> execution (插入 'u')
> ```

## Core

- **编辑距离，需要增加字符**

- **dp[i] [j]表示将word1前i个字符转换成word2前j个字符所需的最少操作数**

- 确定递推公式

  ```swift
  if (word1[i - 1] == word2[j - 1])
      不操作
  if (word1[i - 1] != word2[j - 1])
      增
      删
      换
  ```

  if (word1[i - 1] == word2[j - 1])` 那么说明不用任何编辑，`dp[i] [j]` 就应该是 `dp[i - 1] [j - 1]`，即`dp[i] [j] = dp[i - 1] [j - 1];

​		`if (word1[i - 1] != word2[j - 1])`，此时就需要编辑了，如何编辑呢？

- 操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。

即 `dp[i][j] = dp[i - 1][j] + 1;`

- 操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。

即 `dp[i][j] = dp[i][j - 1] + 1;`

- 操作三：替换元素，`word1`替换`word1[i - 1]`，使其与`word2[j - 1]`相同，此时不用增删加元素。

可以回顾一下，`if (word1[i - 1] == word2[j - 1])`的时候我们的操作 是 `dp[i][j] = dp[i - 1][j - 1]` 对吧。

那么只需要一次替换的操作，就可以让 word1[i - 1] 和 word2[j - 1] 相同。

所以 `dp[i][j] = dp[i - 1][j - 1] + 1;`

## Code

- 时间复杂度: O(n * m)
- 空间复杂度: O(n * m)

```swift
class Solution {
    func minDistance(_ word1: String, _ word2: String) -> Int {
        let m = word1.count
        let n = word2.count
        if m == 0 {
            return n
        } else if n == 0 {
            return m
        }
        let word1Array = Array(word1)
        let word2Array = Array(word2)
        // dp[i][j]表示将word1前i个字符转换成word2前j个字符所需的最少操作数
        var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)

        // 初始化第一行和第一列
        for i in 0 ... m {
            dp[i][0] = i
        }
        for j in 0 ... n {
            dp[0][j] = j
        }

        for i in 1 ... m {
            for j in 1 ... n {
                if word1Array[i - 1] == word2Array[j - 1] {
                    dp[i][j] = dp[i - 1][j - 1]
                } else {
                    dp[i][j] = min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + 1
                }
            }
        }
        return dp[m][n]
    }
}
```

