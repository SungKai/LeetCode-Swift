# 115. 不同的子序列

https://leetcode.cn/problems/distinct-subsequences/

`hard`

**<font color=red>子序列问题</font>**

## 题目描述

> 给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数，结果需要对 109 + 7 取模。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "rabbbit", t = "rabbit"
> 输出：3
> 解释：
> 如下所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
> rabbbit
> rabbbit
> rabbbit
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "babgbag", t = "bag"
> 输出：5
> 解释：
> 如下所示, 有 5 种可以从 s 中得到 "bag" 的方案。 
> babgbag
> babgbag
> babgbag
> babgbag
> babgbag
> ```



## Core

- 编辑距离问题
- **dp[i] [j]表示s前i个字符中t前j个字符出现的个数**

- 确定递推公式

这一类问题，基本是要分析两种情况

- **s[i - 1] 与 t[j - 1]相等**
- **s[i - 1] 与 t[j - 1] 不相等**

当s[i - 1] 与 t[j - 1]相等时，dp[i] [j]可以有两部分组成。

**一部分是用s[i - 1]来匹配，那么个数为dp[i - 1] [j - 1]。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp[i-1] [j-1]。**

**一部分是不用s[i - 1]来匹配，个数为dp[i - 1] [j]。**

```swift
if sArray[i - 1] == tArray[j - 1] {
     dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % mod
} else {
     dp[i][j] = dp[i - 1][j]
}
```

## Code

- 时间复杂度：O(n × m)
- 空间复杂度：O(n × m)

```swift
class Solution {
    func numDistinct(_ s: String, _ t: String) -> Int {
        let mod = 1_000_000_007
        let m = s.count
        let n = t.count
        if m == 0 {
            return 0
        } else if n == 0 {
            return 1
        }

        let sArray = Array(s)
        let tArray = Array(t)
        
        var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)
        // 初始化第一列，表示在s的任何子序列中t为空字符串的出现次数都是1
        for i in 0 ... m {
            dp[i][0] = 1
        }

        for i in 1 ... m {
            for j in 1 ... n {
                if sArray[i - 1] == tArray[j - 1] {
                    dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % mod
                } else {
                    dp[i][j] = dp[i - 1][j]
                }
            }
        }
        return dp[m][n]
    }
}
```

