# 583. 两个字符串的删除操作

https://leetcode.cn/problems/delete-operation-for-two-strings/

`medium`

**<font color=red>子序列问题，转换题意</font>**

## 题目描述

> 给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。
>
> **每步** 可以删除任意一个字符串中的一个字符。
>
>  
>
> **示例 1：**
>
> ```
> 输入: word1 = "sea", word2 = "eat"
> 输出: 2
> 解释: 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"
> ```
>
> **示例  2:**
>
> ```
> 输入：word1 = "leetcode", word2 = "etco"
> 输出：4
> ```

## Core

- 本题和[1143.最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)基本相同，只要求出两个字符串的最长公共子序列长度即可，那么除了最长公共子序列之外的字符都是必须删除的，最后用两个字符串的总长度减去两个最长公共子序列的长度就是删除的最少步数。



## Code

- 时间复杂度：O(n × m)
- 空间复杂度：O(n × m)

```swift
class Solution {
    func minDistance(_ word1: String, _ word2: String) -> Int {
        let m = word1.count
        let n = word2.count

        let word1Array = Array(word1)
        let word2Array = Array(word2)

        var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)
        
        for i in 1 ... m {
            for j in 1 ... n {
                if word1Array[i - 1] == word2Array[j - 1] {
                    dp[i][j] = dp[i - 1][j - 1] + 1
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
                }
            }
        }
        return m + n - dp[m][n] * 2
    }
}
```

