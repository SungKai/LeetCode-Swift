# 62. 不同路径

https://leetcode.cn/problems/unique-paths/

`medium`

**<font color=red>二维数组的动态规划</font>**

## 题目描述

> 一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
>
> 问总共有多少条不同的路径？
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)
>
> ```
> 输入：m = 3, n = 7
> 输出：28
> ```
>
> **示例 2：**
>
> ```
> 输入：m = 3, n = 2
> 输出：3
> 解释：
> 从左上角开始，总共有 3 条路径可以到达右下角。
> 1. 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右
> 3. 向下 -> 向右 -> 向下
> ```
>
> **示例 3：**
>
> ```
> 输入：m = 7, n = 3
> 输出：28
> ```
>
> **示例 4：**
>
> ```
> 输入：m = 3, n = 3
> 输出：6
> ```

## Core

- **二维数组的动态规划**
- 刚开始认为是图论的DFS，但是会超时：时间复杂度为O(2^(m + n - 1) - 1)

- 步骤

  1. 确定dp数组以及下标的含义

     dp[i]的定义为：**表示从（0 ，0）出发，到(i, j) 有dp[i] [j]条不同的路径。**

  2. 确定递推公式

     **状态转移方程:**

     想要求dp[i] [j]，只能有两个方向来推导出来，即dp[i - 1] [j] 和 dp[i] [j - 1]。

     而 dp[i - 1] [j] 表示从(0, 0)的位置到(i - 1, j)有几条路径，dp[i] [j - 1]同理。

     那么很自然，**dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]**，因为dp[i] [j - 1]]只有这两个方向过来。

     

  3. dp数组初始化

     初始化第一行和第一列的路径数量为1，因为只有一种方式可以到达这些位置

     ```swift
     for i in 0 ..< m {
        dp[i][0] = 1
     }
     for j in 0 ..< n {
        dp[0][j] = 1
     }
     ```

     

  4. 确定遍历顺序

     从其上方和左方推导而来

  5. 举例推导dp数组

     ![62.不同路径1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201209113631392.png)

## Code

这个算法的时间复杂度是O(m * n)，其中m和n分别是网格的行数和列数。这是因为我们需要填充一个m x n的二维数组，对于每个位置，我们需要进行一次常数时间的操作。

空间复杂度也是O(m * n)，因为我们使用了一个m x n的二维数组 `dp` 来存储不同位置的路径数量。这个数组的空间消耗与网格的大小成正比。

因此，这个算法在时间和空间上都是与网格大小线性相关的，对于较大的网格也能够高效地计算不同的路径数量。

```swift
class Solution {
    func uniquePaths(_ m: Int, _ n: Int) -> Int {
        var dp = [[Int]](repeating: [Int](repeating: 0, count: n), count: m)

        // 初始化第一行和第一列的路径数量为1，因为只有一种方式可以到达这些位置
        for i in 0 ..< m {
            dp[i][0] = 1
        }
        for j in 0 ..< n {
            dp[0][j] = 1
        }
        // 使用动态规划填充数组，每个位置的路径数量等于上面位置和左边位置的路径数量之和
        for i in 1 ..< m {
            for j in 1 ..< n {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
            }
        }
        // 返回右下角位置的路径数量
        return dp[m - 1][n - 1]
    }
}
```

