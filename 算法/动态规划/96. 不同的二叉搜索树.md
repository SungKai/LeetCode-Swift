# 96. 不同的二叉搜索树

https://leetcode.cn/problems/unique-binary-search-trees/

`medium`

**<font color=red>复杂的状态转移方程</font>**

## 题目描述

> 给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)
>
> ```
> 输入：n = 3
> 输出：5
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 1
> 输出：1
> ```

## Core

- 步骤

1. 确定dp数组以及下标的含义

   dp[i]的定义为：**dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。

2. 确定递推公式

   **状态转移方程:**

   可以从 `i = 1` 开始逐步计算 `dp` 数组的值。对于每个 `i`，我们可以从 `1` 到 `i` 选择一个节点作为根节点，然后将左子树和右子树的节点数量分别为 `j - 1` 和 `i - j`，这样可以计算出 `dp[i]` 的值。

   状态转移方程如下：

   ```swift
   dp[i] = dp[0] * dp[i - 1] + dp[1] * dp[i - 2] + ... + dp[j - 1] * dp[i - j] + ... + dp[i - 1] * dp[0]
   ```

   这个方程表示 `dp[i]` 是从 `1` 到 `i` 中的每个 `j` 都可以选择作为根节点，并将左子树和右子树的数量分别为 `j - 1` 和 `i - j`，然后将它们的数量相乘并累加起来。

   

3. dp数组初始化

   直接初始化：dp[0] = 1

4. 确定遍历顺序

   节点数为i的状态是依靠 i之前节点数的状态。

   那么遍历i里面每一个数作为头结点的状态，用j来遍历。

5. 举例推导dp数组

   ![96.不同的二叉搜索树3](https://code-thinking-1253855093.file.myqcloud.com/pics/20210107093253987.png)

## Code

时间复杂度是O(n^2)，其中n是给定的正整数。因为我们需要填充一个长度为n + 1的数组 `dp`，并且在计算 `dp[i]` 的值时需要一个内部循环。空间复杂度是O(n)，因为我们使用了一个长度为n + 1的数组来存储中间结果。这个算法可以高效地计算不同的二叉搜索树数量。

```swift
class Solution {
    func numTrees(_ n: Int) -> Int {
        if n <= 0 {
            return 0
        }
        var dp = [Int](repeating: 0, count: n + 1)
        dp[0] = 1
        for i in 1 ... n {
            for j in 1 ... i {
                dp[i] += dp[j - 1] * dp[i - j]
            }
        }
        return dp[n]
    }
}
```

