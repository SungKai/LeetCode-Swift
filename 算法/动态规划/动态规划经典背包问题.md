# 动态规划经典背包问题

[视频讲解](https://www.bilibili.com/video/BV1cg411g7Y6/?vd_source=c6f77a89c277cb2e684d92e57f4bb3bc)

0-1 背包和完全背包

## 0-1 背包

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

背包最大重量为4。

物品为：

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

问背包能背的物品最大价值是多少？

### 步骤分析

1. 确定dp数组以及下标的含义

   <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103003361.png" alt="动态规划-背包问题1" style="zoom:67%;" /> 

   dp[i]的定义为：**dp [i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**

2. 确定递推公式

   - **不放物品i**：由dp[i - 1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i] [j]就是dp[i - 1] [j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)
   - **放物品i**：由dp[i - 1] [j - weight[i]]推出，dp[i - 1] [j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么**dp[i - 1] [j - weight[i]] + value[i]** （物品i的价值），就是背包放物品i得到的最大价值

   **状态转移方程:**

   ```swift
   dp[i - 1] [j - weight[i]] + value[i]
   ```

   

3. dp数组初始化

   首先从dp[i] [j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图：

   ![动态规划-背包问题2](https://code-thinking-1253855093.file.myqcloud.com/pics/2021011010304192.png)

    dp[0] [j] = value[0]，表示在考虑只有第一个物品的情况下，当背包容量为 `j` 时，可以获得的最大价值是 `value[0]`。这是初始化过程的一部分，为后续的动态规划提供了一个基准。

4. 确定遍历顺序

   **先遍历物品后遍历背包重量**

5. 举例推导dp数组

   ![动态规划-背包问题4](https://code-thinking-1253855093.file.myqcloud.com/pics/20210118163425129.jpg)

   ## Code

   时间复杂度：

   - 外部循环遍历了物品，有 `n` 个物品，因此是 O(n)。
   - 内部循环遍历了背包容量，有 `bagWeight + 1` 个背包容量，因此是 O(bagWeight)。
   - 在每个循环中，我们执行了常数时间的计算。

   因此，总的时间复杂度是 O(n * bagWeight)，其中 `n` 是物品数量，`bagWeight` 是背包的容量。

   空间复杂度：

   - 我们使用了一个二维数组 `dp`，其大小为 `(n + 1) x (bagWeight + 1)`，因此空间复杂度是 O(n * bagWeight)。

   因此，这个代码的时间复杂度和空间复杂度都是 O(n * bagWeight)

   ```swift
   func knapsack(weight: [Int], value: [Int], bagWeight: Int) -> Int {
   	let n = weight.count
     var dp = [[Int]](repeating: [Int](repeating: 0, count: bagWeight + 1), count: n)
     // 初始化
     for j in weight[0] ... bagWeight {
   		dp[0][j] = value[0]
     }
     // 动态规划
   	for i in 1 ..< n {
       for j in 0 ... bagWeight {
         if j < weight[i] {
           dp[i][j] = dp[i - 1][j]
         } else {
           dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
         }
       }
     }
     return dp[n - 1][bagWeight]
   }
   ```

   













