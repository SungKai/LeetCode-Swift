# 337. 打家劫舍 III

https://leetcode.cn/problems/house-robber-iii/

`medium`

**<font color=red>打家劫舍问题，DFS，哈希表</font>**

## 题目描述

> 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。
>
> 除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。
>
> 给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。
>
>  
>
> **示例 1:**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg)
>
> ```
> 输入: root = [3,2,3,null,3,null,1]
> 输出: 7 
> 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
> ```
>
> **示例 2:**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg)
>
> ```
> 输入: root = [3,4,5,1,3,null,1]
> 输出: 9
> 解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9
> ```



## Core

- 深度优先搜索（DFS）来遍历二叉树，同时使用一个哈希表来记录
- 对于每个节点，我们需要记录两个状态：偷取这个节点的最大金额和不偷取这个节点的最大金额。
- 对于每个节点，如果我们选择偷取它，那么它的子节点不能被偷取，所以偷取这个节点的最大金额等于不偷取其子节点的最大金额之和加上当前节点的值。
- 对于每个节点，如果我们选择不偷取它，那么它的子节点可以被偷取，所以不偷取这个节点的最大金额等于偷取或不偷取其子节点的最大金额之和。
- 我们可以使用递归的方式来遍历整个二叉树，同时使用一个哈希表来记录已经计算过的节点的状态，以避免重复计算。

## Code

1. 时间复杂度：O(n)
   - 其中，n 是二叉树中节点的数量。这是因为我们对每个节点只进行一次遍历，并且在计算每个节点的最大金额时，我们对其左子树和右子树进行了递归调用。因此，总时间复杂度为 O(n)。
2. 空间复杂度：O(n)
   - 在内存使用方面，主要的空间开销来自递归调用栈和哈希表 `memo`。在最坏情况下，递归调用栈的深度将等于树的高度，最坏情况下是 O(n)。哈希表 `memo` 存储了每个节点的状态，因此也需要额外的空间，最坏情况下是 O(n)。所以，总空间复杂度为 O(n)。

```swift
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
extension TreeNode: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(val)  // 使用节点的值作为哈希值的一部分
        hasher.combine(left?.hashValue ?? 0)  // 使用左子节点的哈希值（如果存在）作为哈希值的一部分
        hasher.combine(right?.hashValue ?? 0)  // 使用右子节点的哈希值（如果存在）作为哈希值的一部分
    }
    
    public static func == (lhs: TreeNode, rhs: TreeNode) -> Bool {
        return lhs.val == rhs.val && lhs.left === rhs.left && lhs.right === rhs.right
    }
}

class Solution {
    
    var memo = [TreeNode: (Int, Int)]()
    func rob(_ root: TreeNode?) -> Int {
        return robHelper(root).max
    }
    func robHelper(_ root: TreeNode?) -> (max: Int, notRob: Int) {
        if let node = root {
            if let cached = memo[node] {
                return cached
            }
            // 偷取当前节点，不偷取左右子节点
            let maxRob = node.val + robHelper(node.left).notRob + robHelper(node.right).notRob
            // 不偷取当前节点，可以选择偷取左右子节点的最大金额
            let maxNotRob = max(robHelper(node.left).max, robHelper(node.left).notRob) + max(robHelper(node.right).max, robHelper(node.right).notRob)
            let res = (max(maxRob, maxNotRob), maxNotRob)
            memo[node] = res
            return res 
        } else {
            return (0, 0)
        }
    }
}
```

