# 1049. 最后一块石头的重量 II

https://leetcode.cn/problems/last-stone-weight-ii/

`medium`

**<font color=red>0-1背包问题</font>**

## 题目描述

> 有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。
>
> 每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：
>
> - 如果 `x == y`，那么两块石头都会被完全粉碎；
> - 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。
>
> 最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。
>
>  
>
> **示例 1：**
>
> ```
> 输入：stones = [2,7,4,1,8,1]
> 输出：1
> 解释：
> 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
> 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
> 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
> 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
> ```
>
> **示例 2：**
>
> ```
> 输入：stones = [31,26,33,21,40]
> 输出：5
> ```

## Core

- 与[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)解法类似
- `dp[i]` 表示是否可以达到总重量 i
- 遍历每块石头的重量 `stone`，并对 `dp` 数组进行更新。对于每块石头，从 `totalWeight` 逆序遍历到 `stone`，更新 `dp` 数组。如果 `dp[j - stone]` 为 `true`，则说明可以通过粉碎一些石头得到总重量 `j`。
- 最终，遍历 `dp` 数组，找到最大的 `i`，其中 `dp[i]` 为 `true`。这个 `i` 就是剩下的石头的最小可能重量。

## Code

O(totalWeight * n), O(totalWeight)

```swift
class Solution {
    func lastStoneWeightII(_ stones: [Int]) -> Int {
        let totalWeight = stones.reduce(0, +)
        var dp = [Bool](repeating: false, count: totalWeight + 1)
        dp[0] = true

        for stone in stones {
            for j in stride(from: totalWeight, through: stone, by: -1) {
                dp[j] = dp[j] || dp[j - stone]
            }
        }

        for i in stride(from: totalWeight / 2, through: 0, by: -1) {
            if dp[i] {
                return totalWeight - 2 * i
            }
        } 
        return 0
    }
}
```

