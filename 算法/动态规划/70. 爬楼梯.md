# 70. 爬楼梯

https://leetcode.cn/problems/climbing-stairs/

**<font color=red>简单的DP，按照步骤推导</font>**

## 题目描述

> 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。
>
> 每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
>  
>
> **示例 1：**
>
> ```
> 输入：n = 2
> 输出：2
> 解释：有两种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶
> 2. 2 阶
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 3
> 输出：3
> 解释：有三种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶 + 1 阶
> 2. 1 阶 + 2 阶
> 3. 2 阶 + 1 阶
> ```



## Core

- 步骤

  1. 确定dp数组以及下标的含义

     dp[i]的定义为：dp[i]： 爬到第i层楼梯，有dp[i]种方法

  2. 确定递推公式

     **状态转移方程:**

     从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。

     首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。

     还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。

     

     所以dp[i] = dp[i - 1] + dp[i - 2] 。

  3. dp数组初始化

     dp[0] 是没有意义的

     ```
     dp[1] = 1;
     dp[2] = 2;
     ```

  4. 确定遍历顺序

     从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的

  5. 举例推导dp数组

     按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：

     0 1 2 3 5 8

     如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的

## Code

这个动态规划算法的时间复杂度是O(n)，空间复杂度是O(n)。

时间复杂度分析：

- 我们使用一个循环从3到n来计算每个台阶的方法数，循环的次数是n - 2次，因此时间复杂度是O(n)。

空间复杂度分析：

- 我们使用了一个长度为n + 1的数组 `dp` 来存储中间结果，因此空间复杂度是O(n)。这是因为我们只需要存储每一项的值，而不需要额外的空间。



```swift
class Solution {
    func climbStairs(_ n: Int) -> Int {
        if n <= 0 {
            return -1
        }
        if n == 1 {
            return 1
        } else if n == 2 {
            return 2
        }

        var dp = [Int](repeating: 0, count: n + 1)
        
        dp[1] = 1
        dp[2] = 2

        for i in 3 ... n {
            dp[i] = dp[i - 1] + dp[i - 2]
        }
        return dp[n]
    }
}
```

## 进阶：完全背包

**改为：一步一个台阶，两个台阶，三个台阶，.......，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？**

1阶，2阶，.... m阶就是物品，楼顶就是背包。

每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。

问跳到楼顶有几种方法其实就是问装满背包有几种方法。

**排列**

### Core

- **dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法**。

### Code

- 时间复杂度: O(nm)
- 空间复杂度: O(n)

```swift
func climbStairs(_ n: Int, _ m: Int) -> Int {
  var dp = [Int](repeating: 0, count: n + 1)
  dp[0] = 1
  
  for i in 1 ... n {
		for j in 1 ... m {
			if i - j >= 0 {
				dp[i] += dp[i - j]
      }
    }
  }
  return dp[n]
}
```











