# 746. 使用最小花费爬楼梯

https://leetcode.cn/problems/min-cost-climbing-stairs/

**<font color=red>稍微复杂的状态转移方程</font>**

## 题目描述

> 给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
>
> 你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。
>
> 请你计算并返回达到楼梯顶部的最低花费。
>
>  
>
> **示例 1：**
>
> ```
> 输入：cost = [10,15,20]
> 输出：15
> 解释：你将从下标为 1 的台阶开始。
> - 支付 15 ，向上爬两个台阶，到达楼梯顶部。
> 总花费为 15 。
> ```
>
> **示例 2：**
>
> ```
> 输入：cost = [1,100,1,1,1,100,1,1,100,1]
> 输出：6
> 解释：你将从下标为 0 的台阶开始。
> - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
> - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
> - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
> - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
> - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
> - 支付 1 ，向上爬一个台阶，到达楼梯顶部。
> 总花费为 6 。
> ```



## Core

- 步骤

  1. 确定dp数组以及下标的含义

     dp[i]的定义为：dp[i]： **到达第i台阶所花费的最少体力为dp[i]**

  2. 确定递推公式

     **状态转移方程:**

     **可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。

     dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。

     dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。

     

     选最小的，所以**dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])**;

  3. dp数组初始化

     题目描述中明确说了 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。

     所以初始化 dp[0] = 0，dp[1] = 0;

  4. 确定遍历顺序

     从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的

  5. 举例推导dp数组

     拿示例2：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] ，来模拟一下dp数组的状态变化，如下：

     ![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20221026175104.png)

## Code

这个算法的时间复杂度是O(n)，其中n是台阶的总数，因为我们需要遍历整个费用数组一次来计算最低花费。

空间复杂度也是O(n)，因为我们使用了一个长度为n的数组 `dp` 来存储每个台阶的最低花费。这个数组的空间消耗与台阶数量成线性关系。

因此，这个算法在时间和空间上都是线性的，对于较大的输入也能够高效地计算出达到楼梯顶部的最低花费。

```swift
class Solution {
    func minCostClimbingStairs(_ cost: [Int]) -> Int {
        let n = cost.count
        if n <= 1 {
            return 0
        }
        var dp = [Int](repeating: 0, count: n)

        dp[0] = 0
        dp[1] = 0

        for i in 2 ..< n {
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
        }
        return min(dp[n - 1] + cost[n - 1], dp[n - 2] + cost[n - 2])
    }
}
```

