# 300. 最长递增子序列

https://leetcode.cn/problems/longest-increasing-subsequence/

`medium`

**<font color=red>子序列问题</font>**

## 题目描述

> 给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。
>
> **子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0,1,0,3,2,3]
> 输出：4
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [7,7,7,7,7,7,7]
> 输出：1
> ```

## Core

- **子序列问题**

- **dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度**

- 位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。

  所以：**if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);**



## Code

时间复杂度是O(n^2)，其中n是输入数组`nums`的长度。这是因为我们使用了两层嵌套的循环来计算`dp`数组的值。空间复杂度是O(n)，因为我们使用了一个长度为n的`dp`数组来存储中间状态。

```swift
class Solution {
    func lengthOfLIS(_ nums: [Int]) -> Int {
        if nums.count <= 1 {
            return nums.count
        }
        var dp = [Int](repeating: 1, count: nums.count)
        var res = 1

        for i in 1 ..< nums.count {
            for j in 0 ..< i {
                if nums[i] > nums[j] {
                    dp[i] = max(dp[i], dp[j] + 1)
                }
            }
            res = max(res, dp[i])
        }
        return res
    }
}
```













