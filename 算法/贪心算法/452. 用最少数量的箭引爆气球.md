# 452. 用最少数量的箭引爆气球

https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/

`medium`

**<font color=red>贪心算法 先排序</font>**

## 题目描述

> 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。
>
> 一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足  `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。
>
> 给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：points = [[10,16],[2,8],[1,6],[7,12]]
> 输出：2
> 解释：气球可以用2支箭来爆破:
> -在x = 6处射出箭，击破气球[2,8]和[1,6]。
> -在x = 11处发射箭，击破气球[10,16]和[7,12]。
> ```
>
> **示例 2：**
>
> ```
> 输入：points = [[1,2],[3,4],[5,6],[7,8]]
> 输出：4
> 解释：每个气球需要射出一支箭，总共需要4支箭。
> ```
>
> **示例 3：**
>
> ```
> 输入：points = [[1,2],[2,3],[3,4],[4,5]]
> 输出：2
> 解释：气球可以用2支箭来爆破:
> - 在x = 2处发射箭，击破气球[1,2]和[2,3]。
> - 在x = 4处射出箭，击破气球[3,4]和[4,5]。
> ```



## Core

- 局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。

- 基本思路是首先对气球的区间按照结束坐标（xend）进行排序，然后遍历排序后的区间，用一支箭尽量引爆多的气球。

  以下是使用贪心算法解决这道题的步骤：

  1. 将气球的区间按照结束坐标（xend）进行排序。
  2. 初始化变量 `arrowPos` 为第一个气球的结束坐标，表示第一支箭射出的位置，同时初始化 `arrowCount` 为 1，表示射出的箭数。
  3. 遍历排序后的气球区间：
     - 如果当前气球的开始坐标（xstart）大于 `arrowPos`，说明无法引爆当前气球，需要射出一支箭，并将 `arrowPos` 更新为当前气球的结束坐标。
     - 否则，当前气球可以被当前箭引爆，不需要射出新的箭。
  4. 返回 `arrowCount`，即为所需的最小弓箭数。



## Code

时间复杂度为 O(n log n)，其中 n 是气球的数量，因为我们需要对气球的区间进行排序。空间复杂度为 O(1)，因为只使用了常数级别的额外空间来存储变量

```swift
class Solution {
    func findMinArrowShots(_ points: [[Int]]) -> Int {
        var sortedPoints = points.sorted {
            $0[1] < $1[1]
        }
        var arrowPos = sortedPoints[0][1]
        var arrowCount = 1
        for i in 1 ..< points.count {
            if sortedPoints[i][0] > arrowPos {
                arrowCount += 1
                arrowPos = sortedPoints[i][1]
            }
        }
        return arrowCount
    }
}
```

