# 45. 跳跃游戏 II

https://leetcode.cn/problems/jump-game-ii/

`medium`

**<font color=red>贪心算法</font>**

## 题目描述

> 给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。
>
> 每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:
>
> - `0 <= j <= nums[i]` 
> - `i + j < n`
>
> 返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。
>
>  
>
> **示例 1:**
>
> ```
> 输入: nums = [2,3,1,1,4]
> 输出: 2
> 解释: 跳到最后一个位置的最小跳跃数是 2。
>      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [2,3,0,1,4]
> 输出: 2
> ```



## Core

- 贪心算法：每次在可跳范围内选择可以跳得最远的位置。
- 步骤：
  1. 初始化变量 `steps` 表示跳跃的步数，`maxReach` 表示当前能够跳到的最远位置，`end` 表示当前跳跃范围的末尾位置，初始值都为 0。
  2. 遍历数组中的每个元素 `num` 和对应的下标 `i`：
     - 如果当前的下标 `i` 大于等于 `end`，说明需要再进行一次跳跃，所以步数 `steps` 需要加一，同时更新 `end` 为 `maxReach`，表示当前跳跃范围的末尾位置。
     - 更新 `maxReach` 为 `max(maxReach, i + num)`，表示在当前位置能够跳跃的最远位置。
  3. 遍历结束后，`steps` 就是到达最后一个索引的最小跳跃次数。



## Code

时间复杂度为 O(n)，其中 n 是数组的长度，因为我们只遍历了一次数组。空间复杂度为 O(1)，因为只使用了常数级别的额外空间来存储变量。

```swift
class Solution {
    func jump(_ nums: [Int]) -> Int {
        var steps = 0
        var maxReach = 0
        var end = 0

        for i in 0 ..< nums.count - 1 {
            maxReach = max(maxReach, i + nums[i])
            if i >= end {
                steps += 1
                end = maxReach
            }
        }
        return steps
    }
}
```

