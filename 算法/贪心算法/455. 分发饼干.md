# 455. 分发饼干

https://leetcode.cn/problems/assign-cookies/

**<font color=red>贪心算法</font>**

## 题目描述

> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
>
> 对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
>
>  
>
> **示例 1:**
>
> ```
> 输入: g = [1,2,3], s = [1,1]
> 输出: 1
> 解释: 
> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
> 所以你应该输出1。
> ```
>
> **示例 2:**
>
> ```
> 输入: g = [1,2], s = [1,2,3]
> 输出: 2
> 解释: 
> 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
> 你拥有的饼干数量和尺寸都足以让所有孩子满足。
> 所以你应该输出2.
> ```



## Core

- **贪心算法**: 每次选择当前最优的解，然后逐步构建出全局最优解。
- 在这个问题中，可以按照孩子的胃口值和饼干的尺寸进行排序，然后从胃口最小的孩子开始，尝试分配尺寸最小的饼干。

## Code

这段代码的时间复杂度取决于排序操作和遍历操作。

1. 排序操作：排序孩子的胃口值和饼干的尺寸分别需要 O(n log n) 的时间复杂度，其中 n 分别为孩子的数量和饼干的数量。
2. 遍历操作：在最坏情况下，需要同时遍历整个孩子数组和饼干数组，这部分的时间复杂度是 O(n)，其中 n 是孩子或饼干的数量。

因此，总的时间复杂度为 O(n log n) + O(n)，这里主要取决于排序操作。

空间复杂度方面，除了输入数组外，代码中使用了少量的额外空间来存储几个整数变量和循环中的临时变量，所以空间复杂度可以近似看作是 O(1)。

```swift
class Solution {
    func findContentChildren(_ g: [Int], _ s: [Int]) -> Int {
        let sortedG = g.sorted()
        let sortedS = s.sorted()

        var childIndex = 0
        var cookieIndex = 0
        var satisfiedCount = 0

        while childIndex < sortedG.count, cookieIndex < sortedS.count {
            // 如果当前饼干尺寸可以满足当前孩子的胃口
            if sortedS[cookieIndex] >= sortedG[childIndex] {
                satisfiedCount += 1
                childIndex += 1  // 移动到下一个孩子
            }
            cookieIndex += 1  // 无论是否满足，都要尝试下一个饼干
        }
        return satisfiedCount
    }
}
```

