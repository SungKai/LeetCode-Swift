# 376. 摆动序列

https://leetcode.cn/problems/wiggle-subsequence/

`medium`

**<font color=red>贪心算法：维护一个当前摆动序列的状态以及最长摆动序列的长度</font>**

## 题目描述

> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
>
> - 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
> - 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
>
> **子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
>
> 给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,7,4,9,2,5]
> 输出：6
> 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,17,5,10,13,15,10,5,16,8]
> 输出：7
> 解释：这个序列包含几个长度为 7 摆动序列。
> 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [1,2,3,4,5,6,7,8,9]
> 输出：2
> ```



## Core

- **贪心算法**: **维护一个当前摆动序列的状态以及最长摆动序列的长度**。在遍历数组的过程中，我们可以根据当前元素与前一个元素的大小关系来更新状态，并且根据状态来更新最长摆动序列的长度。

- 用 `prevDiff` 来记录当前元素与前一个元素之间的差值。如果差值的正负与前一个差值的正负不同，说明摆动状态发生了变化，这时我们可以将最长摆动序列的长度加一，并更新 `prevDiff`。



## Code

时间复杂度： 在这个算法中，我们**只需要一次遍历整个数组**，每次操作都是基于前一个元素和当前元素的差值，所以时间复杂度是 O(n)，其中 n 是输入数组的长度。

空间复杂度： 这个算法只**使用了几个变量来保存状态和结果，所以空间复杂度是 O(1)**，也就是常数级别的额外空间。无论输入数组的长度如何增加，算法所需的额外空间都保持不变。

```swift
class Solution {
    func wiggleMaxLength(_ nums: [Int]) -> Int {
        if nums.count < 2 {
            return nums.count
        }

        var prevDiff = nums[1] - nums[0]
        var maxLength = prevDiff != 0 ? 2 : 1
        for i in 2 ..< nums.count {
            let currDiff = nums[i] - nums[i - 1]
            if (currDiff > 0 && prevDiff <= 0) || (currDiff < 0 && prevDiff >= 0) {
                maxLength += 1
                prevDiff = currDiff
            }
        }
        return maxLength
    }
}
```

