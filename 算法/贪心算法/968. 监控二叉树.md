# 968. 监控二叉树

https://leetcode.cn/problems/binary-tree-cameras/

`hard`

**<font color=red>贪心的思路，遍历和状态推导</font>**

## 题目描述

> 给定一个二叉树，我们在树的节点上安装摄像头。
>
> 节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**
>
> 计算监控树的所有节点所需的最小摄像头数量。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png)
>
> ```
> 输入：[0,0,null,0,0]
> 输出：1
> 解释：如图所示，一台摄像头足以监控所有节点。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png)
>
> ```
> 输入：[0,0,null,0,null,0,null,null,0]
> 输出：2
> 解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。
> ```



## Core

- **贪心的思路，遍历和状态推导**

- **局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！**

- 我们分别有三个数字来表示：

  - 0：该节点无覆盖
  - 1：本节点有摄像头
  - 2：本节点有覆盖

- 空节点不能是无覆盖的状态，这样叶子节点就要放摄像头了，空节点也不能是有摄像头的状态，这样叶子节点的父节点就没有必要放摄像头了，而是可以把摄像头放在叶子节点的爷爷节点上。

  **所以空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了**



## Code

空间复杂度主要取决于递归调用栈的深度，它与树的高度有关。在最坏情况下，如果二叉树是一条链（单边树），则递归调用栈的深度将是N，因此空间复杂度是O(N)。在平衡二叉树的情况下，递归调用栈的深度通常是log(N)，因此空间复杂度是O(log(N))。

总之，这个算法的时间复杂度是O(N)，空间复杂度在最坏情况下是O(N)，在平衡树的情况下是O(log(N))。

```swift
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public var val: Int
 *     public var left: TreeNode?
 *     public var right: TreeNode?
 *     public init() { self.val = 0; self.left = nil; self.right = nil; }
 *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }
 *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
 *         self.val = val
 *         self.left = left
 *         self.right = right
 *     }
 * }
 */
class Solution {
    var count = 0
    func minCameraCover(_ root: TreeNode?) -> Int {
        let res = dfs(root)
        return res == 0 ? count + 1 : count
    }
    // 返回值为0表示该节点未被覆盖，1表示该节点有摄像头，2表示该节点被覆盖
    func dfs(_ node: TreeNode?) -> Int {
        guard let node = node else {
            return 2
        }
        let left = dfs(node.left)
        let right = dfs(node.right)
        // 1.如果左右子节点有一个未被覆盖，当前节点需要放置摄像头
        if left == 0 || right == 0 {
            count += 1
            return 1
        } else if left == 1 || right == 1 {
            // 2.如果左右子节点有一个有摄像头，当前节点被覆盖
            return 2
        } else {
            // 3.如果左右子节点都被覆盖但没有摄像头，需要父节点放置摄像头
            return 0
        }
    } 
}

```

