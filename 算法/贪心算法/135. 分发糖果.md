# 135. 分发糖果

https://leetcode.cn/problems/candy/

`hard`

**<font color=red>贪心策略:需要使用两次贪心算法</font>**

## 题目描述

> `n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。
>
> 你需要按照以下要求，给这些孩子分发糖果：
>
> - 每个孩子至少分配到 `1` 个糖果。
> - 相邻两个孩子评分更高的孩子会获得更多的糖果。
>
> 请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：ratings = [1,0,2]
> 输出：5
> 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
> ```
>
> **示例 2：**
>
> ```
> 输入：ratings = [1,2,2]
> 输出：4
> 解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
>      第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
> ```



## Core

- 贪心的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼。需要使用两次贪心算法
- 基本思路是先从左到右遍历一遍，保证右边评分更高的孩子比左边的孩子糖果数量更多。然后再从右到左遍历一遍，保证左边评分更高的孩子比右边的孩子糖果数量更多。

## Code

时间复杂度为 O(n)，其中 n 是孩子的数量，因为我们只遍历了两次数组。空间复杂度为 O(n)，用于存储糖果数量的数组。

```swift
class Solution {
    func candy(_ ratings: [Int]) -> Int {
        let n = ratings.count
        var candies = Array(repeating: 1, count: n)

        for i in 1 ..< n {
            if ratings[i] > ratings[i - 1] {
                candies[i] = candies[i - 1] + 1
            }
        }

        for i in (0 ..< n - 1).reversed() {
            if ratings[i] > ratings[i + 1], candies[i] <= candies[i + 1] {
                candies[i] = candies[i + 1] + 1
            }
        }
        return candies.reduce(0, +)
    }
}
```

