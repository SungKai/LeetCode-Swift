# 763. 划分字母区间

https://leetcode.cn/problems/partition-labels/)

`medium`

**<font color=red>用最远出现距离模拟了圈字符的行为</font>**

## 题目描述

> 给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。
>
> 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。
>
> 返回一个表示每个字符串片段的长度的列表。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "ababcbacadefegdehijhklij"
> 输出：[9,7,8]
> 解释：
> 划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
> 每个字母最多出现在一个片段中。
> 像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "eccbbbbdec"
> 输出：[10]
> ```



## Core

- 局部最优：在每一步遍历中，我们都尽可能地扩大 `end`，以便包含尽可能多的相同字符，这是局部最优策略，因为这样可以确保当前片段的最小长度。

  全局最优：通过不断更新 `end` 和计算每个片段的长度，我们最终得到了划分字符串的全局最优策略，使得所有片段的长度尽可能小，并且满足题目要求。

- 基本思路是遍历字符串 `s`，并维护两个变量 `start` 和 `end`，它们分别表示当前正在考虑的片段的起始和结束位置。遍历过程中，如果遇到字符，将其最后一次出现的位置更新为 `end`。当当前位置达到 `end` 时，表示当前片段结束，记录其长度，并将 `start` 更新为下一个字符的位置。

## Code

时间复杂度是 O(n)，其中 n 是字符串 `s` 的长度，因为我们只需要遍历字符串两次。空间复杂度是 O(1)，因为我们只使用了常数额外空间

```swift
class Solution {
    func partitionLabels(_ s: String) -> [Int] {
        // 存储每个字符最后出现的位置
        var lastIndices = [Int](repeating: -1, count: 26)
        var aAsciiValue = Int(Character("a").asciiValue!)

        for (i, char) in s.enumerated() {
            let charIndex = Int(char.asciiValue!) - aAsciiValue
            lastIndices[charIndex] = i
        }
        
        var start = 0
        var end = 0
        var partitions = [Int]()

        for (i, char) in s.enumerated() {
            let charIndex = Int(char.asciiValue!) - aAsciiValue
            end = max(end, lastIndices[charIndex])
            if i == end {
                partitions.append(end - start + 1)
                start = i + 1
            }
        }
        return partitions
    }
}
```







