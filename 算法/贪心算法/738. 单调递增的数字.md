# 738. 单调递增的数字

https://leetcode.cn/problems/monotone-increasing-digits/)

`medium`

**<font color=red>找到一个规则，使得从高位到低位逐位确定每一位数字，以保持整数的单调递增性质</font>**

## 题目描述

> 当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。
>
> 给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。
>
>  
>
> **示例 1:**
>
> ```
> 输入: n = 10
> 输出: 9
> ```
>
> **示例 2:**
>
> ```
> 输入: n = 1234
> 输出: 1234
> ```
>
> **示例 3:**
>
> ```
> 输入: n = 332
> 输出: 299
> ```



## Core

- 关键在于**找到一个规则，使得从高位到低位逐位确定每一位数字，以保持整数的单调递增性质**。关键步骤如下：
  1. 从高位到低位遍历每一位数字，找到第一个不满足单调递增性质的位置（即当前位数字大于下一位数字的位置）。
  2. 如果找到了不满足单调递增性质的位置，将当前位减 1，然后将当前位后面的所有位数都设置为 9，以保持单调递增性质。
  3. 继续处理下一位数字，直到处理完所有位数或者已经得到了一个单调递增的整数。

## Code

时间复杂度是 O(log n) 的原因是因为我们需要处理整数 `n` 的每一位数字。通常来说，整数 `n` 有大约 log10(n) 位数字，其中 log10 表示以 10 为底的对数。因此，遍历整数 `n` 的每一位数字的操作的时间复杂度是 O(log n)。

空间复杂度是 O(log n)，用于存储数字的数组。

```swift
class Solution {
    func monotoneIncreasingDigits(_ n: Int) -> Int {
        var digits = Array(String(n).compactMap {
            Int(String($0))
        })
        var i = 1
        // 从高位到低位遍历
        while i < digits.count, digits[i - 1] <= digits[i] {
            i += 1
        }
        // 如果 i < digits.count，说明发现了不满足单调递增的位置
        if i < digits.count {
            // 将当前位减 1
            var j = i - 1
            while j > 0, digits[j] == digits[j - 1] {
                j -= 1
            }
            digits[j] -= 1
            // 将当前位后面的所有位数设置为 9
            for k in j + 1 ..< digits.count {
                digits[k] = 9
            }
        }
        // 将数组中的数字重新组合成整数
        return digits.reduce(0) {
            $0 * 10 + $1
        }
    }
}
```

