# 图论

图是树的升级版。图通常分为有向（directed）或无向（undirected），有循环（cyclic）或无循环（acyclic），所有节点相连（connected）或不相连（disconnected）。

树即是一个相连的无向无环图，而另一种很常见的图是有向无环图（Directed Acyclic Graph，DAG）。

 有向无环图：

![image-20230823153410297](/Users/songjiaming/Library/Application Support/typora-user-images/image-20230823153410297.png)



图通常有两种表示方法。假设图中一共有 *n* 个节点、*m* 条边。

- 第一种表示方法是**邻接矩阵** （adjacency matrix）：我们可以建立一个 *n*× *n* 的矩阵 G，如果第 i 个节点连向第 j 个节点，则 G[i][j]= 1，反之为 0；如果图是无向的，则这个矩阵一定是**对称矩阵**，即 G[i][j] = G[j][i]。
- 第二种表示方法是**邻接链表**（adjacency list）：我们可以建立一个大小为 *n* 的数组，每个位置 i 储存一个数组或者链表，表示第 i 个节点连向的其它节点。邻接矩阵空间开销比邻接链表大，但是邻接链表不支持快速查找 i 和 j 是否相连，因此两种表示方法可以根据题目需要适当选择。除此之外，我也可以直接用一个 *m* × 2 的矩阵储存所有的边

## 深度搜索和广度搜索

深搜（dfs）是一条路跑到黑然后再**回溯**。

广搜（bfs）是一圈一圈的搜索过程。

- dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。
- bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。

**dfs 适合有方向性的搜索**

**bfs 适合解决两个点之间的最短路径问题**

> BFS一圈一圈的遍历方式，所以一旦遇到终止点，那么一定是一条最短路径。
>
> 从图中可以看出，如果添加了障碍，我们是第六步才能走到end终点：
>
> <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220825103900.png" alt="图三" style="zoom: 50%;" /> 

