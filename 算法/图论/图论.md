# 图论

图是树的升级版。图通常分为有向（directed）或无向（undirected），有循环（cyclic）或无循环（acyclic），所有节点相连（connected）或不相连（disconnected）。

树即是一个相连的无向无环图，而另一种很常见的图是有向无环图（Directed Acyclic Graph，DAG）。

 有向无环图：

![image-20230823153410297](/Users/songjiaming/Library/Application Support/typora-user-images/image-20230823153410297.png)



图通常有两种表示方法。假设图中一共有 *n* 个节点、*m* 条边。

- 第一种表示方法是**邻接矩阵** （adjacency matrix）：我们可以建立一个 *n*× *n* 的矩阵 G，如果第 i 个节点连向第 j 个节点，则 G[i][j]= 1，反之为 0；如果图是无向的，则这个矩阵一定是**对称矩阵**，即 G[i][j] = G[j][i]。
- 第二种表示方法是**邻接链表**（adjacency list）：我们可以建立一个大小为 *n* 的数组，每个位置 i 储存一个数组或者链表，表示第 i 个节点连向的其它节点。邻接矩阵空间开销比邻接链表大，但是邻接链表不支持快速查找 i 和 j 是否相连，因此两种表示方法可以根据题目需要适当选择。除此之外，我也可以直接用一个 *m* × 2 的矩阵储存所有的边

## 深度搜索和广度搜索

深搜（dfs）是一条路跑到黑然后再**回溯**。

广搜（bfs）是一圈一圈的搜索过程。

- dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。
- bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。

**dfs 适合有方向性的搜索**

**bfs 适合解决两个点之间的最短路径问题**

> BFS一圈一圈的遍历方式，所以一旦遇到终止点，那么一定是一条最短路径。
>
> 从图中可以看出，如果添加了障碍，我们是第六步才能走到end终点：
>
> <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220825103900.png" alt="图三" style="zoom: 50%;" /> 



DFS（深度优先搜索）和BFS（广度优先搜索）都可以得到正确的答案。它们的主要区别在于搜索顺序和实现方式，以及在某些情况下的性能。

1. **搜索顺序**：
   - DFS：DFS沿着一个路径**尽可能深入地搜索，直到达到最深的节点，然后回溯并继续搜索下一个分支**。因此，DFS通常会沿着一条路径一直走到底，然后再返回。
   - BFS：**BFS从起始节点开始，首先搜索所有相邻的节点，然后进一步搜索它们的相邻节点**，以此类推。BFS通常会以层次结构遍历图或矩阵，从起始节点开始逐层扩展。
2. **实现方式**：
   - DFS通常使用**递归**或显式的堆栈来实现。
   - BFS通常使用队列来实现。
3. **性能**：
   - 在某些情况下，DFS可能会在树或图的**深度较小**的情况下更快，因为它**不需要维护一个队列**，但在深度较大的情况下，DFS可能会导致栈溢出。
   - BFS通常需要使用队列来存储节点，因此在深度较大的情况下，可能会占用更多的内存。

## 并查集

1135.最低成本联通所有城市.md 中