# 1971. 寻找图中是否存在路径

https://leetcode.cn/problems/find-if-path-exists-in-graph/)

**<font color=red>并查集, 如果边的数量较大，这个算法可能比 DFS 或 BFS 更高效</font>**

## 题目描述

> 有一个具有 `n` 个顶点的 **双向** 图，其中每个顶点标记从 `0` 到 `n - 1`（包含 `0` 和 `n - 1`）。图中的边用一个二维整数数组 `edges` 表示，其中 `edges[i] = [ui, vi]` 表示顶点 `ui` 和顶点 `vi` 之间的双向边。 每个顶点对由 **最多一条** 边连接，并且没有顶点存在与自身相连的边。
>
> 请你确定是否存在从顶点 `source` 开始，到顶点 `destination` 结束的 **有效路径** 。
>
> 给你数组 `edges` 和整数 `n`、`source` 和 `destination`，如果从 `source` 到 `destination` 存在 **有效路径** ，则返回 `true`，否则返回 `false` 。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/08/14/validpath-ex1.png)
>
> ```
> 输入：n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2
> 输出：true
> 解释：存在由顶点 0 到顶点 2 的路径:
> - 0 → 1 → 2 
> - 0 → 2
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/08/14/validpath-ex2.png)
>
> ```
> 输入：n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5
> 输出：false
> 解释：不存在由顶点 0 到顶点 5 的路径.
> ```

## Core

- **并查集,如果边的数量较大，这个算法可能比 DFS 或 BFS 更高效**

- 首先使用一个数组 `parent` 来表示并查集，初始化时每个节点的父节点是自己。然后，定义了 `find` 函数用于查找节点的根节点，实现了路径压缩，以提高查找效率。同时，定义了 `union` 函数用于合并两个节点所在的集合。

  接下来，遍历边的数组 `edges`，对每条边进行合并操作，将两个节点所在的集合合并为一个。最后，检查源节点 `source` 和目标节点 `destination` 是否属于同一个集合，如果是，则存在有效路径，返回 `true`，否则返回 `false`。

## Code

时间复杂度：

- 构建并查集的过程需要遍历边的数组 `edges`，时间复杂度为 O(E)，其中 **E 是边的数量**。
- 并查集的 `find` 和 `union` 操作的时间复杂度取决于并查集的深度，通常接近 O(1)，因为路径压缩和按秩合并的优化技巧可以保持并查集的性能。
- 最后，检查源节点 `source` 和目标节点 `destination` 是否属于同一个集合，也需要 O(1) 时间。

总体时间复杂度是 O(E)。

空间复杂度：

- 空间复杂度主要取决于并查集的数据结构，即数组 `parent`，其空间占用为 O(n)，其中 n 是节点的数量。

总体空间复杂度是 O(n)。

需要注意的是，虽然这个算法在查找和合并操作上具有很好的性能，但在构建并查集时需要遍历边的数组，因此时间复杂度与边的数量有关。在实际应用中，**如果边的数量较大，这个算法可能比 DFS 或 BFS 更高效**。

```swift
class Solution {
    func validPath(_ n: Int, _ edges: [[Int]], _ source: Int, _ destination: Int) -> Bool {
        var parent = Array(0 ..< n)

        // 定义并查集的操作
        func find(_ node: Int) -> Int {
            if parent[node] == node {
                return node
            }
            parent[node] = find(parent[node])  
            return parent[node]
        }

        // 合并
        func union(_ u: Int, _ v: Int) {
            let rootU = find(u)
            let rootV = find(v)
            if rootU != rootV {
                parent[rootU] = rootV
            }
        }

        // 合并边的两个节点
        for edge in edges {
            let u = edge[0]
            let v = edge[1]
            union(u, v)
        }
        return find(source) == find(destination)
    }
}
```











