# 685. 冗余连接 II

https://leetcode.cn/problems/redundant-connection-ii/

`hard`

**<font color=red>复杂的并查集</font>**

## 题目描述

> 在本问题中，有根树指满足以下条件的 **有向** 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。
>
> 输入一个有向图，该图由一个有着 `n` 个节点（节点值不重复，从 `1` 到 `n`）的树及一条附加的有向边构成。附加的边包含在 `1` 到 `n` 中的两个不同顶点间，这条附加的边不属于树中已存在的边。
>
> 结果图是一个以边组成的二维数组 `edges` 。 每个元素是一对 `[ui, vi]`，用以表示 **有向** 图中连接顶点 `ui` 和顶点 `vi` 的边，其中 `ui` 是 `vi` 的一个父节点。
>
> 返回一条能删除的边，使得剩下的图是有 `n` 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg)
>
> ```
> 输入：edges = [[1,2],[1,3],[2,3]]
> 输出：[2,3]
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2020/12/20/graph2.jpg)
>
> ```
> 输入：edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]
> 输出：[4,1]
> ```



## Core

- 并查集：首先找到**两条潜在的冗余边**，然后通过并查集操作来确定哪一条是真正的冗余边。这个算法能够有效地解决这个问题，并返回冗余边的信息。
  - `ans1` 和 `ans2` 是两个数组，用于存储两条潜在的冗余边。
    1. `ans1` 是一个数组，用于存储第一条潜在的冗余边。在代码中，如果发现某个节点 `v` 已经有了父节点（**也就是说入度已经为1了，再加上目前遍历到的这个，入度就为2了**），那么当前边就有可能是一条冗余边。此时，代码会将父节点和节点 `v` 组成的边存储在 `ans1` 中。
    2. `ans2` 也是一个数组，用于存储第二条潜在的冗余边。在代码中，无论是否已经找到了第一条潜在的冗余边，都会将当前边存储在 `ans2` 中。这样，即使第一条边不是真正的冗余边，`ans2` 中仍然包含了**所有输入边中的最后一条边**。

## Code

**时间复杂度：**

1. 第一次遍历 `edges` 数组用于初始化 `parents` 数组，这是一个 O(n) 操作，其中 n 是边的数量。
2. 第二次遍历 `edges` 数组进行并查集操作，涉及到 `find` 操作和合并操作。通常情况下，**`find` 操作的时间复杂度是接近于 O(1) 的（由于路径压缩）**，而合并操作的时间复杂度是接近于 O(1) 的（由于按秩合并）。因此，第二次遍历的时间复杂度是 O(n)。

所以，总的时间复杂度是 O(n)。

**空间复杂度：**

1. `parents`、`roots` 和 `sizes` 数组的空间复杂度都是 O(n)，因为它们的长度与输入边的数量成线性关系。
2. `ans1` 和 `ans2` 数组的空间复杂度是 O(1)，因为它们只存储一对边的信息。
3. 在 `find` 函数中使用了一个临时变量 `res`，因此空间复杂度是 O(1)。

所以，总的空间复杂度是 O(n)。

综上所述，这个算法具有线性的时间复杂度和线性的空间复杂度，是一个相对高效的解决方案。

```swift
class Solution {
    func findRedundantDirectedConnection(_ edges: [[Int]]) -> [Int] {
        let n = edges.count
        var parents = Array(repeating: 0, count: n + 1)
        var roots = Array(repeating: 0, count: n + 1)
        var sizes = Array(repeating: 1, count: n + 1)

        var ans1 = [Int]()
        var ans2 = [Int]()

        for edge in edges {
            let u = edge[0]
            let v = edge[1]
            
            // 如果 parents[v] 大于 0，说明节点 v 已经有了父节点，这时候就发现了一个潜在的冗余边，将其存储在 ans1 中，同时将当前边存储在 ans2 中。
            if parents[v] > 0 {
                ans1 = [parents[v], v]
                ans2 = edge
            }
            parents[v] = u
        }
        // 第一次遍历结束后，我们已经找到了两条潜在的冗余边，分别存储在 ans1 和 ans2 中。接下来，将执行并查集的操作，以判断哪一条边是真正的冗余边。
        for edge in edges {
            let u = edge[0]
            let v = edge[1]
            // 如果当前边等于 ans2，则跳过，因为这是我们已经确定的潜在冗余边。
            if !ans2.isEmpty, u == ans2[0], v == ans2[1] {
                continue
            }
            // 初始化或更新节点 u 和节点 v 的根节点，如果它们还没有根节点。
            if roots[u] == 0 {
                roots[u] = u
            }
            if roots[v] == 0 {
                roots[v] = v
            }
            // 使用 find 函数查找节点 u 和节点 v 的根节点。
            let rootU = find(u)
            let rootV = find(v)

            // 如果它们的根节点相同（形成了环），那么我们找到了真正的冗余边。如果 ans1 不为空，返回 ans1，否则返回当前边。
            if rootU == rootV {
                return ans1.isEmpty ? edge : ans1
            }
            
            // 否则，将节点 u 和节点 v 合并到同一个集合中，并更新相应的根节点和集合大小。
            if sizes[rootU] > sizes[rootV] {
                // 意味着根节点 rootU 所在的集合比根节点 rootV 所在的集合大。为了保持树的平衡，将根节点 rootV 的父节点指向根节点 rootU，并增加根节点 rootU 所在集合的大小 sizes[rootU]，以反映新合并的集合的大小。
                roots[rootV] = rootU
                sizes[rootU] += sizes[rootV]
            } else {
                roots[rootU] = rootV
                sizes[rootV] += sizes[rootU]
            }
        }

        // 查找节点的根节点
        func find(_ node: Int) -> Int {
            if node == roots[node] {
                return node
            }
            roots[node] = find(roots[node])
            return roots[node]
        }
        return ans2
    }
}


```

