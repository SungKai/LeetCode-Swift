# 1020. 飞地的数量

https://leetcode.cn/problems/number-of-enclaves/

`medium`

**<font color=red>DFS岛屿问题</font>**

## 题目描述

> 给你一个大小为 `m x n` 的二进制矩阵 `grid` ，其中 `0` 表示一个海洋单元格、`1` 表示一个陆地单元格。
>
> 一次 **移动** 是指从一个陆地单元格走到另一个相邻（**上、下、左、右**）的陆地单元格或跨过 `grid` 的边界。
>
> 返回网格中 **无法** 在任意次数的移动中离开网格边界的陆地单元格的数量。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg) 
>
> ```
> 输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
> 输出：3
> 解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg) 
>
> ```
> 输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
> 输出：0
> 解释：所有 1 都在边界上或可以到达边界。
> ```



## Core

- DFS岛屿问题



## Code

O(rows * cols), O(rows * cols)

```swift
class Solution {
    func numEnclaves(_ grid: [[Int]]) -> Int {
        var grid = grid
        let rows = grid.count
        let cols = grid[0].count

        for i in 0 ..< rows {
            for j in 0 ..< cols {
                if i == 0 || i == rows - 1 || j == 0 || j == cols - 1 {
                    if grid[i][j] == 1 {
                        dfs(&grid, i, j)
                    }
                }
            }
        }

        var count = 0
        for i in 0 ..< rows {
            for j in 0 ..< cols {
                if grid[i][j] == 1 {
                    count += 1  
                }
            }
        }
        return count
    }
    func dfs(_ grid: inout [[Int]], _ row: Int, _ col: Int) {
        let rows = grid.count
        let cols = grid[0].count
        if row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] == 0 {
            return
        }
        grid[row][col] = 0
        dfs(&grid, row + 1, col)
        dfs(&grid, row - 1, col)
        dfs(&grid, row, col + 1)
        dfs(&grid, row, col - 1)
    }
}
```

