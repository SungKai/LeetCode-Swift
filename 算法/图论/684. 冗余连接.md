# 684. 冗余连接

https://leetcode.cn/problems/redundant-connection/

`medium`

**<font color=red>并查集，只要查找到两个元素已经属于同个集合了，就可以删除他们现在连接的这条边</font>**

## 题目描述

> 树可以看成是一个连通且 **无环** 的 **无向** 图。
>
> 给定往一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后的图。添加的边的两个顶点包含在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。
>
> 请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的那个。
>
>  
>
> **示例 1：**
>
> ![img](https://pic.leetcode-cn.com/1626676174-hOEVUL-image.png)
>
> ```
> 输入: edges = [[1,2], [1,3], [2,3]]
> 输出: [2,3]
> ```
>
> **示例 2：**
>
> ![img](https://pic.leetcode-cn.com/1626676179-kGxcmu-image.png)
>
> ```
> 输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]
> 输出: [1,4]
> ```



## Core

- **并查集，只要查找到两个元素已经属于同个集合了，就可以删除他们现在连接的这条边**

  

## Code

时间复杂度：

- 构建并查集的过程需要遍历边的数组 `edges`，时间复杂度为 O(E)，其中 E 是边的数量。
- 并查集的 `find` 和 `union` 操作的时间复杂度取决于并查集的深度，通常接近 O(1)，因为路径压缩和按秩合并的优化技巧可以保持并查集的性能。

总体时间复杂度是 O(E)。

空间复杂度：

- 算法的空间复杂度主要取决于并查集的数据结构，即数组 `parent`，其空间占用为 O(n)，其中 n 是节点的数量。

总体空间复杂度是 O(n)。

需要注意的是，虽然这个算法在查找和合并操作上具有很好的性能，但在构建并查集时需要遍历边的数组，因此时间复杂度与边的数量有关。

```swift
class Solution {
    func findRedundantConnection(_ edges: [[Int]]) -> [Int] {
        let n = edges.count
        var parent = Array(0 ..< n + 1)

        func find(_ node: Int) -> Int {
            if node == parent[node] {
                return node
            }
            parent[node] = find(parent[node])
            return parent[node]
        }

        func union(_ u: Int, _ v: Int) -> Bool {
            let rootU = find(u)
            let rootV = find(v)
            if rootU == rootV {
                return false
            }
            parent[rootU] = rootV
            return true
        }

        for edge in edges {
            let u = edge[0]
            let v = edge[1]
            if !union(u, v) {
                return edge
            }
        }
        return []
    }
}
```

