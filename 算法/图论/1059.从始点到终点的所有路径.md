# 1059.从始点到终点的所有路径

`medium`

**<font color=red>图论，dfs，需要回溯</font>**

## 题目描述

> 给定有向图的边 edges，以及该图的始点 source 和目标终点 destination，确定从始点 source 出发的所有路径是否最终结束于目标终点 destination，即：
>
> - 从始点 source 到目标终点 destination 存在至少一条路径
> - 如果存在从始点 source 到没有出边的节点的路径，则该节点就是路径终点。
> - 从始点source到目标终点 destination 可能路径数是有限数字
>
> 当从始点 source 出发的所有路径都可以到达目标终点 destination 时返回 true，否则返回 false。
>
> 示例 1： 
>
> ![在这里插入图片描述](https://ask.qcloudimg.com/http-save/yehe-6980195/1k8mn0qtus.png)
>
> ```javascript
> 输入：n = 3, edges = [[0,1],[0,2]], source = 0, destination = 2
> 输出：false
> 说明：节点 1 和节点 2 都可以到达，但也会卡在那里。
> ```
>
> 
>
> 示例 2： 
>
> ![在这里插入图片描述](https://ask.qcloudimg.com/http-save/yehe-6980195/e3pph8z9hg.png)
>
> ```javascript
> 输入：n = 4, edges = [[0,1],[0,3],[1,2],[2,1]], source = 0, destination = 3
> 输出：false
> 说明：有两种可能：在节点 3 处结束，或是在节点 1 和节点 2 之间无限循环。
> ```
>
> 
>
> 示例 3： 
>
> ![在这里插入图片描述](https://ask.qcloudimg.com/http-save/yehe-6980195/k8eejnm3h4.png)
>
> ```javascript
> 输入：n = 4, edges = [[0,1],[0,2],[1,3],[2,3]], source = 0, destination = 3
> 输出：true
> ```
>
> 
>
> 示例 4： 
>
> ![在这里插入图片描述](https://ask.qcloudimg.com/http-save/yehe-6980195/uticyvfq5j.png)
>
> ```javascript
> 输入：n = 3, edges = [[0,1],[1,1],[1,2]], source = 0, destination = 2
> 输出：false
> 说明：从始点出发的所有路径都在目标终点结束，
> 但存在无限多的路径，如 0-1-2，0-1-1-2，0-1-1-1-2，0-1-1-1-1-2 等。
> ```
>
> 
>
> 示例 5： 
>
> ![在这里插入图片描述](https://ask.qcloudimg.com/http-save/yehe-6980195/12yrxa0aen.png)
>
> ```
> 输入：n = 2, edges = [[0,1],[1,1]], source = 0, destination = 1
> 输出：false
> 说明：在目标节点上存在无限的自环。
>  
> 提示：
> 给定的图中可能带有自环和平行边。
> 图中的节点数 n 介于 1 和 10000 之间。
> 图中的边数在 0 到 10000 之间。
> 0 <= edges.length <= 10000
> edges[i].length == 2
> 0 <= source <= n - 1
> 0 <= destination <= n - 1
> ```



## Core

- 图论，dfs，需要回溯
- 首先创建了一个图，然后使用深度优先搜索函数 `dfs` 来遍历从源节点开始的所有路径。在每一步中，我们检查当前节点是否有出边，如果没有出边，则检查是否是目标终点。如果当前节点已经被访问过，说明存在**环路**，返回 false。否则，我们继续递归地遍历当前节点的邻居节点。最后，我们在回溯时重置访问标志，以便在不同路径间进行切换。



## Code

**时间复杂度分析：**

- **创建图的过程需要遍历所有的边**，每条边执行常数时间的操作，**因此创建图的时间复杂度为 O(E)**，其中 E 是边的数量。
- 在深度优先搜索过程中，每个节点最多会被访问一次，每次访问时都要遍历其邻居节点。由于在遍历过程中，每个节点的邻居节点最多只会被遍历一次，所以在遍历过程中总共的操作次数与边的数量成正比。因此，DFS 的时间复杂度为 O(E)。

综合起来，这段代码的总体时间复杂度是 O(E)。

**空间复杂度分析：**

- 图的存储需要使用额外的空间，用于存储每个节点的邻居节点列表。在最坏情况下，每个节点都有出边连接到其他所有节点，因此额外的空间复杂度是 O(E)。
- 在深度优先搜索过程中，使用了一个 `visited` 数组来跟踪节点是否已经被访问过。这个数组的长度为节点的数量，因此额外的空间复杂度是 O(N)，其中 N 是节点的数量。

综合起来，这段代码的总体空间复杂度是 O(N + E)，其中 N 是节点的数量，E 是边的数量。

```swift
func leadsToDestination(_ n: Int, _ edges: [[Int]], _ source: Int, _ destination: Int) -> Bool {
  var graph: [Int: [Int]] = [:]
  for edge in edges {
    let from = edge[0]
    let to = edge[1]
    if graph[from] == nil {
			graph[from] = []  // 预防没有出边
    }
    graph[from]?.append(to)
  }
  
  
  var visited: [Bool] = Array(repeating: false, count: n) 
  func dfs(_ node: Int) -> Bool {
		if graph[node] == nil {
			return node == destination
    }
    if visited[node] == true {
      return false
    }
    visited[node] = true
    for neighbor in graph[node]! {
      if !dfs(neighbor) {
        return false
      }
    }
    visited[node] = false
  }
  
  return dfs(source)
}
```













