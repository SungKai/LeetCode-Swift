# 200. 岛屿数量

https://leetcode.cn/problems/number-of-islands/

`medium`

**<font color=red>DFS 和BFS 均可</font>**

## 题目描述

> 给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。
>
> 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
>
> 此外，你可以假设该网格的四条边均被水包围。
>
>  
>
> **示例 1：**
>
> ```
> 输入：grid = [
>   ["1","1","1","1","0"],
>   ["1","1","0","1","0"],
>   ["1","1","0","0","0"],
>   ["0","0","0","0","0"]
> ]
> 输出：1
> ```
>
> **示例 2：**
>
> ```
> 输入：grid = [
>   ["1","1","0","0","0"],
>   ["1","1","0","0","0"],
>   ["0","0","1","0","0"],
>   ["0","0","0","1","1"]
> ]
> 输出：3
> ```

## Core

- DFS 和BFS 均可

- 思路是用遇到一个没有遍历过的节点陆地，计数器就加一，然后把该节点陆地所能遍历到的陆地都标记上。

  在遇到**标记过的陆地节点**和海洋节点的时候直接跳过。 这样计数器就是最终岛屿的数量。

## Code

DFS

时间复杂度：

- 在最坏情况下，DFS会遍历整个网格中的每个单元格，每个单元格只会被访问一次，因此时间复杂度是O(rows * cols)，其中rows和cols分别是网格的行数和列数。

空间复杂度：

- 空间复杂度由递归调用和存储递归状态的数据结构决定。在最坏情况下，递归调用的最大深度是整个网格的大小，因此递归调用的空间复杂度是O(rows * cols)。此外，还有一个名为 `grid` 的副本，因此整体的空间复杂度是O(rows * cols)。

```swift
class Solution {
    // dfs
    func numIslands(_ grid: [[Character]]) -> Int {
        var grid = grid
        var count = 0

        for i in 0 ..< grid.count {
            for j in 0 ..< grid[0].count {
                if grid[i][j] == "1" {
                    count += 1
                    dfs(&grid, i, j)
                }
            }
        }
        return count
    }
    func dfs(_ grid: inout [[Character]], _ row: Int, _ col: Int) {
        let rows = grid.count
        let cols = grid[0].count

        if row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] == "0" {
            return
        }
        // 标记已经访问了
        grid[row][col] = "0"
        // 访问周围
        dfs(&grid, row + 1, col)
        dfs(&grid, row - 1, col)
        dfs(&grid, row, col + 1)
        dfs(&grid, row, col - 1)
    }
}
```

BFS

时间复杂度：

- 与DFS一样，在最坏情况下，BFS会遍历整个网格中的每个单元格，每个单元格只会被访问一次，因此时间复杂度是O(rows * cols)，其中rows和cols分别是网格的行数和列数。

空间复杂度：

- 空间复杂度由BFS队列和存储已访问状态的数据结构决定。在最坏情况下，BFS队列可能包含整个网格的大小，因此空间复杂度是O(rows * cols)。此外，还有一个名为 `grid` 的副本，因此整体的空间复杂度是O(rows * cols)。

```swift
class Solution {
    // bfs
    func numIslands(_ grid: [[Character]]) -> Int {
        var grid = grid
        var count = 0
        let rows = grid.count
        let cols = grid[0].count
        for i in 0 ..< grid.count {
            for j in 0 ..< grid[0].count {
                if grid[i][j] == "1" {
                    count += 1
                    var queue: [(Int, Int)] = [(i, j)]
                    while !queue.isEmpty {
                        let (row, col) = queue.removeLast()
                        if row >= 0, row < rows, col >= 0, col < cols, grid[row][col] == "1" {
                            grid[row][col] = "0"
                            queue.append((row + 1, col))
                            queue.append((row - 1, col))
                            queue.append((row, col + 1))
                            queue.append((row, col - 1))
                        }
                    }
                }
            }
        }
        return count
    }
}
```

