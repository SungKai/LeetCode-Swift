# 797. 所有可能的路径

https://leetcode.cn/problems/all-paths-from-source-to-target/

`medium`

**<font color=red>有向图路径问题，最合适使用深搜 + 回溯算法</font>**

## 题目描述

> 给你一个有 `n` 个节点的 **有向无环图（DAG）**，请你找出所有从节点 `0` 到节点 `n-1` 的路径并输出（**不要求按特定顺序**）
>
>  `graph[i]` 是一个从节点 `i` 可以访问的所有节点的列表（即从节点 `i` 到节点 `graph[i][j]`存在一条有向边）。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg)
>
> ```
> 输入：graph = [[1,2],[3],[3],[]]
> 输出：[[0,1,3],[0,2,3]]
> 解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg)
>
> ```
> 输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]
> 输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
> ```

## Core

- 有向图路径问题，最合适使用深搜 + 回溯算法



## Code

时间复杂度：

- 在最坏情况下，算法需要遍历所有可能的路径，因此时间复杂度为O(2^N)，其中N是图中节点的数量。

空间复杂度：

- 空间复杂度主要由递归调用和存储路径的数据结构决定。
- 递归调用的最大深度是图中节点的数量，因此递归调用的空间复杂度是O(N)。
- 存储路径的数据结构（`currentPath`和`paths`数组）也会占用额外的空间，最坏情况下可能需要**存储所有可能的路径**。因此，空间复杂度也是O(2^N)，与时间复杂度相对应。

```swift
class Solution {
    func allPathsSourceTarget(_ graph: [[Int]]) -> [[Int]] {
        var paths = [[Int]]()
        var currentPath = [Int]()
        dfs(graph, 0, &paths, &currentPath)
        return paths
    }
    func dfs(_ graph: [[Int]], _ node: Int, _ paths: inout [[Int]], _ currentPath: inout [Int]) {
        currentPath.append(node)
        if node == graph.count - 1 {
            paths.append(currentPath)
        } else {
            for neighbor in graph[node] {
                dfs(graph, neighbor, &paths, &currentPath)
            }
        }
        currentPath.removeLast()
    }
}
```

