# 130. 被围绕的区域

https://leetcode.cn/problems/surrounded-regions/

`medium`

**<font color=red>DFS岛屿问题: 与[1020. 飞地的数量](https://leetcode.cn/problems/number-of-enclaves/)刚好相反，解决问题思路一致，多加反转模拟</font>**

## 题目描述

> 给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` ，找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)
>
> ```
> 输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
> 输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
> 解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
> ```
>
> **示例 2：**
>
> ```
> 输入：board = [["X"]]
> 输出：[["X"]]
> ```

## Core

- 与[1020. 飞地的数量](https://leetcode.cn/problems/number-of-enclaves/)刚好相反，解决问题思路一致，多加反转模拟
  - 首先遍历矩阵的边界，找到所有边界上的 'O' 并使用DFS标记它们以及与之相连的 'O' 为特殊字符 '*'。*
  - *然后，遍历整个矩阵，将所有的 'O' 替换为 'X'，将特殊字符 '*' 还原为 'O'。

## Code

```swift
class Solution {
    func solve(_ board: inout [[Character]]) {
        if board.isEmpty || board[0].isEmpty {
            return
        }
        
        let rows = board.count
        let cols = board[0].count

        // 将边界上的 'O' 及其连通的 'O' 标记为特殊字符，比如 '*'
        for i in 0 ..< rows {
            for j in 0 ..< cols {
                if i == 0 || i == rows - 1 || j == 0 || j == cols - 1 {
                    if board[i][j] == "O" {
                        dfs(&board, i, j)
                    }
                }
            }
        }
        // 处理剩余的 'O' 和还原特殊字符
        for i in 0 ..< rows {
            for j in 0 ..< cols {
                if board[i][j] == "O" {
                    board[i][j] = "X"
                } else if board[i][j] == "*" {
                    board[i][j] = "O"
                }
            }
        }
    }
    func dfs(_ board: inout [[Character]], _ row: Int, _ col: Int) {
        let rows = board.count
        let cols = board[0].count
        if row < 0 || row >= rows || col < 0 || col >= cols || board[row][col] != "O" {
            return
        }
        board[row][col] = "*"
        dfs(&board, row + 1, col)
        dfs(&board, row - 1, col)
        dfs(&board, row, col + 1)
        dfs(&board, row, col - 1)
    }
}
```

