# 210. 课程表 II

https://leetcode.cn/problems/course-schedule-ii/

`medium`

**<font color=red>拓扑排序 BFS 邻接矩阵</font>**

## 题目描述

> 现在你总共有 `numCourses` 门课需要选，记为 `0` 到 `numCourses - 1`。给你一个数组 `prerequisites` ，其中 `prerequisites[i] = [ai, bi]` ，表示在选修课程 `ai` 前 **必须** 先选修 `bi` 。
>
> - 例如，想要学习课程 `0` ，你需要先完成课程 `1` ，我们用一个匹配来表示：`[0,1]` 。
>
> 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 **任意一种** 就可以了。如果不可能完成所有课程，返回 **一个空数组** 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：numCourses = 2, prerequisites = [[1,0]]
> 输出：[0,1]
> 解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
> ```
>
> **示例 2：**
>
> ```
> 输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
> 输出：[0,2,1,3]
> 解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
> 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
> ```
>
> **示例 3：**
>
> ```
> 输入：numCourses = 1, prerequisites = []
> 输出：[0]
> ```



## Core

- 我们可以先建立一个**邻接矩阵**表示图，方便进行直接查找。这里注意我们将所有的边反向， 使得如果课程i指向课程j，那么课程i需要在课程j前面先修完。这样更行合我们的直观理解。

  **拓扑排序**也可以被看成是**广度优先搜索**的一种情况：我们先遍历一遍所有节点，把入度为0 的节点（即没有前置课程要求） 放在队列中。在每次从队列中尖得节点时，我们将该节点放在日前排序的末尾，并且把它指向的课程的人度各减1；如果在这个过程中有课程的所有前置必修课都已修完（即入度为0)，我们把这个节点加人队列中。当队列的节点都被处理完时，说明所有的节点都己排好序，或因图中存在循环而无法上完所有课程。



## Code

时间复杂度分析：

1. 构建图和计算入度的时间复杂度：O(E)，其中 E 是 prerequisites 数组的长度，表示课程的先修关系数量。
2. 初始化队列的时间复杂度：O(V)，其中 V 是课程数量，即 numCourses。
3. 在 while 循环中，每个节点（课程）最多会被处理一次，每个边（先修关系）也最多会被考虑一次，因此循环的时间复杂度为 O(E)。
4. 总体时间复杂度为 O(E + V)。

空间复杂度分析：

1. graph 字典的空间复杂度：O(E)，因为每个节点最多与其他节点建立一条边，所以每个节点的邻接列表平均长度为 O(1)。
2. indegree 数组的空间复杂度：O(V)，因为需要存储每个节点的入度。
3. queue 的空间复杂度：O(V)，最坏情况下可能需要存储所有节点。
4. result 数组的空间复杂度：O(V)，最坏情况下需要存储所有节点的学习顺序。
5. 总体空间复杂度为 O(E + V)。

综上所述，这段代码的时间复杂度为 O(E + V)，空间复杂度也为 O(E + V)。其中 E 表示课程的先修关系数量，V 表示课程数量。

```swift
class Solution {
    func findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {
        var graph = [Int: [Int]]()  // [先行者: 依赖者]
        var indegree = [Int](repeating: 0, count: numCourses)  // 依赖者所依赖的课程数量
        for edge in prerequisites {
            let course = edge[0]  // 依赖者
            let prerequisite = edge[1]  // 先行者/被依赖者
            graph[prerequisite, default: []].append(course)
            indegree[course] += 1
        }

        var queue = [Int]()
        for i in 0 ..< numCourses {
            if indegree[i] == 0 {
                queue.append(i)  // 一节课都不需要依赖的课程
            }
        }
        var res = [Int]()
        while !queue.isEmpty {
            let node = queue.removeFirst()
            res.append(node)
            if let neighbors = graph[node] {
                for neighbor in neighbors {
                    indegree[neighbor] -= 1
                    if indegree[neighbor] == 0 {
                        queue.append(neighbor)
                    }
                }
            }
        }
        if res.count != numCourses {
            return []
        }
        return res
    }
}
```

