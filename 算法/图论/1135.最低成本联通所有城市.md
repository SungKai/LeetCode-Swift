# 1135.最低成本联通所有城市

`medium`

**<font color=red>最小生成树：Kruskal算法，并查集</font>**

## 题目描述

> 想象一下你是个城市基建规划者，地图上有 N 座城市，它们按以 1 到 N 的次序编号。
>
> 给你一些可连接的选项 conections，其中每个选项 `conections[i] = [city1, city2, cost]` 表示将城市 city1 和城市 city2 连接所要的成本。（连接是双向的，也就是说城市 city1 和城市 city2 相连也同样意味着城市 city2 和城市 city1 相连）。
>
> 返回使得每对城市间都存在将它们连接在一起的连通路径（可能长度为 1 的）**最小成本**。 该最小成本应该是所用全部连接代价的综合。如果根据已知条件无法完成该项任务，则请你返回 -1。
>
> 示例 1： 
>
> ![在这里插入图片描述](https://ask.qcloudimg.com/http-save/yehe-6980195/gvzo32fgwm.png)
>
> ```javascript
> 输入：N = 3, conections = [[1,2,5],[1,3,6],[2,3,1]]
> 输出：6
> 解释：
> 选出任意 2 条边都可以连接所有城市，我们从中选取成本最小的 2 条。
> ```
>
> 
>
> 示例 2： 
>
> ![在这里插入图片描述](https://ask.qcloudimg.com/http-save/yehe-6980195/twhh1e9n0t.png)
>
> ```javascript
> 输入：N = 4, conections = [[1,2,3],[3,4,4]]
> 输出：-1
> 解释： 
> 即使连通所有的边，也无法连接所有城市。
>  
> 提示：
> 1 <= N <= 10000
> 1 <= conections.length <= 10000
> 1 <= conections[i][0], conections[i][1] <= N
> 0 <= conections[i][2] <= 10^5
> conections[i][0] != conections[i][1]
> ```



## Core

- **最小生成树：Kruskal算法**

  - Kruskal算法是一种用于解决最小生成树（Minimum Spanning Tree，MST）问题的贪心算法。最小生成树是一个连通无向图中的一棵包含所有顶点的树，同时具有最小的边权重之和。

    Kruskal算法的主要思想是从图的边集合中逐步选择边，将它们添加到最小生成树中，同时保持生成树的连通性，直到生成树包含了所有的顶点为止。算法的基本步骤如下：

    1. 将所有边按照权重从小到大排序。
    2. 初始化一个空的最小生成树。
    3. 逐个考虑排序后的边，如果当前边连接的两个顶点在最小生成树中不在同一个连通分量中（即不会形成环），则将这条边加入最小生成树，并将这两个顶点合并为一个连通分量。
    4. 重复步骤3，直到最小生成树中包含了所有的顶点。

    Kruskal算法使用**并查集（Union-Find）**数据结构来管理顶点之间的连通性，以确保新添加的边不会形成环。这样，算法每次选择的边都是当前不会造成环且权重最小的边，从而保证了生成的树是最小生成树。

    总之，Kruskal算法是一种高效且简单的方法，用于在连通图中找到最小生成树。它的时间复杂度通常为**O(E log E)**，其中E是边的数量。

- **并查集**

  - 并查集（Union-Find）是一种**用于维护集合的数据结构**，它支持两种主要操作：合并（Union）和查找（Find）。并查集常常用于解决关于元素分组、连通性和集合合并的问题。

    在并查集中，每个元素被视为一个节点，这些节点通过一些特定的规则构成了不同的集合。每个集合由一个代表元素来表示。这个数据结构的主要目标是快速地判断两个元素是否属于同一个集合，以及在需要的时候将两个集合合并在一起。

    主要的操作有：

    1. **查找（Find）：** **给定一个元素，查找该元素所属的集合（也就是代表元素）**。**这个操作主要用于判断两个元素是否在同一个集合中**。
    2. **合并（Union）：** **将两个不同集合合并为一个集合。**这个操作可以通过修改两个集合的代表元素，将其中一个集合的代表元素指向另一个集合的代表元素，从而实现合并。

    并查集通常用于解决图论中的连通性问题，例如在Kruskal算法中的使用，以及社交网络中的关系分组等场景。在实际应用中，通常会采用一些优化策略，例如路径压缩和按秩合并（rank-based union），以保证并查集的高效性能。

    路径压缩通过将查找路径上的每个节点都直接连接到根节点，减少查找路径的长度，从而加速后续查找操作。按秩合并通过维护每个节点的秩（树的高度的一个上界），在合并时始终将秩较小的树连接到秩较大的树，以保持树的平衡，进而提高效率。

  - 在代码中，为`var parent = Array(0...N)`, 用于实现并查集（Union-Find）数据结构中的**"父节点"或"根节点"的存储**。

    在并查集数据结构中，通常用一个数组来表示每个元素的父节点。在这里，`parent` 数组的索引表示城市的编号，数组的值表示该城市的父节点的编号。初始情况下，通常将每个城市的父节点初始化为自身，表示每个城市是一个单独的集合。这就是为什么 `Array(0...N)` 会创建一个包含从0到N的整数的数组，因为每个城市最初都是自己的父节点。

    在后续的并查集操作中，`parent` 数组的值会不断更新，以反映集合的合并。这是实现并查集的关键之一，用于确定元素所属的集合，以及在需要时将两个集合合并在一起。



## Code

**时间复杂度：**

1. `sortedConnections` 排序的时间复杂度：O(E * log E)，其中 E 是边的数量，因为我们对所有边进行了一次排序。
2. `find` 操作的时间复杂度：O(log N)，其中 N 是城市的数量。路径压缩会让查找路径的长度保持较小。
3. `union` 操作的时间复杂度：O(1)。在每次合并操作中，我们执行了常数次数的操作，包括查找 `root1` 和 `root2`，以及可能的父节点更新。

整体来说，排序是主要的时间开销，所以最终的时间复杂度主要取决于排序操作，即 O(E * log E)，其中 E 是边的数量。

**空间复杂度：**

1. `parent` 数组的空间复杂度：O(N)，其中 N 是城市的数量。
2. `rank` 数组的空间复杂度：O(N)，同样是因为它需要为每个城市维护秩。
3. `root1` 和 `root2` 的变量空间复杂度：O(1)，这是临时变量。
4. `totalCost` 和 `numEdges` 的变量空间复杂度：O(1)，这是临时变量。

综上所述，该代码的总空间复杂度为 O(N)。

```swift
class Solution {
    func minimumCost(_ N: Int, _ connections: [[Int]]) -> Int {
        // 首先对 connections 数组进行排序，以便按照连接成本从小到大处理
        let sortedConnections = connections.sorted {
          $0[2] < $1[2]
        }
        var parent = Array(0 ... N)  // 用于存储每个城市的父节点，初始化为每个城市自己。
        var rank = Array(repeating: 1, count: N + 1)  // 用于表示树的高度（或秩），初始化为 1
        
        // 并查集的查找操作。给定一个城市编号，函数递归地查找该城市的根节点，并在查找路径上进行路径压缩，以提高查找效率。
        func find(_ city: Int) -> Int {
            if parent[city] != city {
                parent[city] = find(parent[city])
            }
            return parent[city]
        }
        
        // 并查集的合并操作。它接受两个城市编号，首先找到它们的根节点，然后根据秩进行合并，以保持树的平衡。
        func union(_ city1: Int, _ city2: Int) -> Bool {
            let root1 = find(city1)
            let root2 = find(city2)
            if root1 == root2 {  // 他们已经在同一个组了
                return false
            }
            if rank[root1] > rank[root2] {
                parent[root2] = root1
            } else if rank[root1] < rank[root2] {
                parent[root1] = root2
            } else {
                parent[root2] = root1
                rank[root1] += 1
            }
            return true
        }
        
        var totalCount = 0  // 记录已经加入最小生成树的边的总成本
        var numEdges = 0  // 录已经加入最小生成树的边的数量
        
        // 遍历已经按成本排序的边连接
        for connection in sortedConnections {
            let city1 = connection[0]
            let city2 = connection[1]
            let cost = connection[2]
            
            // 调用 union 函数，如果成功合并两个城市，即它们原本不在同一个集合中，那么将边的成本加入 totalCost，并增加 numEdges
            if union(city1, city2) {
                totalCount += cost
                numEdges += 1
            }
            if numEdges == N - 1 {
                break  // 所有城市都已经连接好
            }
        }
        return numEdges == N - 1 ? totalCount : -1
    }
}
```

