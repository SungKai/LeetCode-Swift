# 84. 柱状图中最大的矩形

https://leetcode.cn/problems/largest-rectangle-in-histogram/

`hard`

**<font color=red>单调递增栈</font>**

## 题目描述

> 给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
>
> 求在该柱状图中，能够勾勒出来的矩形的最大面积。
>
>  
>
> **示例 1:**
>
> ![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)
>
> ```
> 输入：heights = [2,1,5,6,2,3]
> 输出：10
> 解释：最大的矩形为图中红色区域，面积为 10
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)
>
> ```
> 输入： heights = [2,4]
> 输出： 4
> ```

## Core

- **单调递增栈**来存储柱子的索引。遍历每个柱子时，如果当前柱子的高度小于栈顶柱子的高度，就表示栈顶柱子无法再向右扩展，可以计算栈顶柱子的面积并更新最大面积。然后将栈顶柱子弹出，直到当前柱子高度不小于栈顶柱子的高度或者栈为空。

  最后，遍历完所有柱子后，可能栈中还有柱子未处理，需要继续计算面积，因为这些柱子的右边界是数组的末尾。将这些柱子逐个弹出并计算面积，再次更新最大面积。

- 模拟过程：

  当 `heights = [2, 1, 5, 6, 2, 3]` 时，我们来模拟一下整个计算最大矩形面积的过程。

  初始状态：栈为空，最大矩形面积 `maxArea = 0`。

  1. 处理第一个柱子 `heights[0] = 2`：
     - 栈为空，所以将当前柱子的索引0入栈。
     - 栈状态：[0]

  2. 处理第二个柱子 `heights[1] = 1`：
     - 当前柱子的高度小于栈顶柱子 `heights[0] = 2` 的高度。
     - 弹出栈顶柱子，计算栈顶柱子的矩形面积：`height = 2`, `width = 1`，矩形面积为 `2 * 1 = 2`。
     - 栈状态：栈为空，所以将当前柱子的索引1入栈。
     - 最大矩形面积更新为2。

  3. 处理第三个柱子 `heights[2] = 5`：
     - 当前柱子的高度大于栈顶柱子 `heights[1] = 1` 的高度。
     - 将当前柱子的索引2入栈。
     - 栈状态：[1, 2]

  4. 处理第四个柱子 `heights[3] = 6`：
     - 当前柱子的高度大于栈顶柱子 `heights[2] = 5` 的高度。
     - 将当前柱子的索引3入栈。
     - 栈状态：[1, 2, 3]

  5. 处理第五个柱子 `heights[4] = 2`：
     - 当前柱子的高度小于栈顶柱子 `heights[3] = 6` 的高度。
     - 弹出栈顶柱子，计算栈顶柱子的矩形面积：`height = 6`, `width = 1`，矩形面积为 `6 * 1 = 6`。
     - 继续弹出栈顶柱子，计算栈顶柱子的矩形面积：`height = 5`, `width = 2`，矩形面积为 `5 * 2 = 10`。
     - 栈状态：[1]

  6. 处理第六个柱子 `heights[5] = 3`：
     - 当前柱子的高度小于栈顶柱子 `heights[1] = 1` 的高度。
     - 弹出栈顶柱子，计算栈顶柱子的矩形面积：`height = 1`, `width = 5`，矩形面积为 `1 * 5 = 5`。
     - 栈状态：[1]

  7. 遍历结束，栈中剩余的柱子是没有更小柱子的右边界。
     - 弹出栈顶柱子，计算栈顶柱子的矩形面积：`height = 1`, `width = 6`，矩形面积为 `1 * 6 = 6`。

  最大矩形面积为这些矩形面积的最大值，即 `max(2, 10, 5, 6) = 10`。

  所以，给定 `heights = [2, 1, 5, 6, 2, 3]`，最大矩形面积为10。

## Code

O(n), O(n)

```swift
class Solution {
    func largestRectangleArea(_ heights: [Int]) -> Int {
        let n = heights.count
        var stack = [Int]()
        var maxArea = 0

        for i in 0 ..< n {
            while !stack.isEmpty, heights[i] < heights[stack.last!] {
                let top = stack.popLast()!
                let width = stack.isEmpty ? i : i - stack.last! - 1
                let height = heights[top]
                maxArea = max(maxArea, width * height)
            }
            stack.append(i)
        }
        while !stack.isEmpty {
            let height = heights[stack.popLast()!]
            let width = stack.isEmpty ? n : n - stack.last! - 1
            maxArea = max(maxArea, height * width)
        }
        return maxArea
    }
}
```

