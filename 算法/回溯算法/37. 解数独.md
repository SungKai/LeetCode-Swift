# 37. 解数独

https://leetcode.cn/problems/sudoku-solver/

`hard`

**<font color=red>棋盘问题：二维的递归回溯</font>**

## 题目描述

> 编写一个程序，通过填充空格来解决数独问题。
>
> 数独的解法需 **遵循如下规则**：
>
> 1. 数字 `1-9` 在每一行只能出现一次。
> 2. 数字 `1-9` 在每一列只能出现一次。
> 3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）
>
> 数独部分空格内已填入了数字，空白格用 `'.'` 表示。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)
>
> ```
> 输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
> 输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
> 解释：输入的数独如上图所示，唯一有效的解决方案如下所示：
> ```



## Core

- 与[51. N 皇后](https://leetcode.cn/problems/n-queens/)不同：每一行每一列只放一个皇后，只需要一层for循环遍历一行，递归来遍历列，然后一行一列确定皇后的唯一位置。**本题中棋盘的每一个位置都要放一个数字（而N皇后是一行只放一个皇后），并检查数字是否合法，解数独的树形结构要比N皇后更宽更深**。
- 需要使用**二维的递归回溯**



## Code

时间复杂度：

- `solveSudoku(_ board: inout [[Character]])` 函数是主函数，其中最主要的部分是 `backtracking()` 函数的递归调用。
- 在 `backtracking` 函数中，双重循环遍历了整个 9x9 数独盘，每个格子可能会尝试 1 到 9 的数字。所以，递归的总次数将是 9^81，因为每个格子最多尝试 9 个数字。
- 在 `isValid(_ row: Int, _ col: Int, _ val: Character)` 函数中，每个校验步骤都需要遍历一次，所以校验的时间复杂度是 O(9)。

综上所述，整个算法的时间复杂度是 O(9^(81+1))，可以简化为 O(9^82)。

空间复杂度：

- 这段代码的主要空间开销在于修改了输入的 `board` 数组。在最坏情况下，`board` 数组的大小是 9x9，所以空间复杂度是 O(1)。
- 递归调用会使用到系统栈空间，最坏情况下会有 81 层递归调用，因为每个格子最多尝试 9 个数字。所以空间复杂度为 O(81)，即 O(1)。

综上所述，代码的时间复杂度是 O(9^82)，空间复杂度是 O(1)。

```swift
class Solution {
    func solveSudoku(_ board: inout [[Character]]) {
        func isValid(_ row: Int, _ col: Int, _ val: Character) -> Bool {
            // 行中是否重复
            for i in 0 ..< 9 {
                if board[row][i] == val {
                    return false
                }
            }
            // 列中是否重复
            for i in 0 ..< 9 {
                if board[i][col] == val {
                    return false
                }
            }
            // 9方格内是否重复
            let startRow = row / 3 * 3
            let startCol = col / 3 * 3 
            for i in startRow ..< startRow + 3 {
                for j in startCol ..< startCol + 3 {
                    if board[i][j] == val {
                        return false
                    }
                }
            }
            return true
        }

        @discardableResult
        func backtracking() -> Bool {
            for i in 0 ..< board.count {
                for j in 0 ..< board[0].count {
                    guard board[i][j] == "." else {
                        continue
                    }
                    for val in 1 ... 9 {
                        let charVal = Character("\(val)")
                        guard isValid(i, j, charVal) else {
                            continue
                        }
                        board[i][j] = charVal
                        if backtracking() {
                            return true
                        }
                        board[i][j] = "."
                    }
                    // 遍历完数字都不行
                    return false
                }
            }
            return true
        }
        backtracking()
    }
}
```

