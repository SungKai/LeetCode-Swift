# 491. 递增子序列

https://leetcode.cn/problems/non-decreasing-subsequences/

`medium`

**<font color=red>回溯+哈希表查看是否有重复</font>**

## 题目描述

> 给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。
>
> 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [4,6,7,7]
> 输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [4,4,3,2,1]
> 输出：[[4,4]]
> ```



## Core

- 回溯+哈希表查看是否有重复

## Code

时间复杂度分析：

- 外部函数 `findSubsequences` 包含了一个内部的回溯函数 `backtracking` 的调用。
- 在 `backtracking` 函数中，通过 `for` 循环遍历数组中的元素，每个元素都会被尝试添加到 `path` 中，然后进行递归调用。
- 每个元素都有两种情况：被添加到路径中或者不被添加到路径中。因此，对于每个元素，都有两个分支。
- 因此，回溯的总体操作次数将会是指数级别的，因为对于每个元素，我们都有两个分支。即使在最坏情况下不是所有的组合都会添加到 `res` 中，但由于其指数增长的特性，时间复杂度会很高。

综上所述，代码的时间复杂度是指数级别的，通常表示为O(2^N)，其中 N 是数组的长度。

空间复杂度分析：

- 在 `backtracking` 函数中，使用了 `path` 数组来保存当前正在构建的子序列。
- 使用了一个 `uset` 集合来检查重复元素。
- 在递归调用过程中，`path` 数组和 `uset` 集合都会不断地被修改和回溯。
- 由于递归的深度取决于数组的长度，并且每层递归会使用额外的空间来存储 `path` 和 `uset` 的副本，因此空间复杂度也会是指数级别的。

综上所述，代码的空间复杂度是指数级别的，通常表示为O(2^N)。

```swift
class Solution {
    func findSubsequences(_ nums: [Int]) -> [[Int]] {
        var res = [[Int]]()
        var path = [Int]()
        func backtracking(_ startIndex: Int) {
            if path.count > 1 {
                res.append(path)
            }
            var uset = Set<Int>()
            let end = nums.count
            guard startIndex < end else {
                return
            }
            for i in startIndex ..< end {
                let num = nums[i]
                if uset.contains(num) {
                    continue
                }
                if !path.isEmpty, num < path.last! {
                    continue
                }
                uset.insert(num)
                path.append(num)
                backtracking(i + 1)
                path.removeLast()
            }
        }
        backtracking(0)
        return res
    }
}
```

