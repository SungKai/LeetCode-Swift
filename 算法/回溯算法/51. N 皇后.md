# 51. N 皇后

https://leetcode.cn/problems/n-queens/

`hard`

**<font color=red>棋盘问题：回溯算法</font>**

## 题目描述

> 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。a
>
> **n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。
>
> 给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。
>
> 每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)
>
> ```
> 输入：n = 4
> 输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
> 解释：如上图所示，4 皇后问题存在两个不同的解法。
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 1
> 输出：[["Q"]]
> ```



## Core

- 棋盘问题：回溯算法：**棋盘的宽度就是for循环的长度，递归的深度就是棋盘的高度，这样就可以套进回溯法的模板里了**。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130182532303.jpg" alt="51.N皇后" style="zoom:50%;" />

- 皇后们的约束条件`isValid`中只需要查看当前棋子的上方：
  1. 不能同行：**startIndex：+1**
  2. 不能同列：**正上方**
  3. 不能同斜线
     1. 45度：**左上方**
     2. 135度：**右上方**

## Code

O(n!), O(n)

```swift
class Solution {
    func solveNQueens(_ n: Int) -> [[String]] {
        var res = [[String]]()
        var chessboard = [[Character]](repeating: [Character](repeating: ".", count: n), count: n)
        func isValid(_ row: Int, _ col: Int) -> Bool {
            // 检查列
            for i in 0 ..< row {
                if chessboard[i][col] == "Q" {
                    return false
                }
            }
            var i: Int
            var j: Int
            // 检查45度
            i = row - 1
            j = col - 1
            while i >= 0, j >= 0 {
                if chessboard[i][j] == "Q" {
                    return false
                }
                i -= 1
                j -= 1
            }
            // 检查135度
            i = row - 1
            j = col + 1
            while i >= 0, j < n {
                if chessboard[i][j] == "Q" {
                    return false
                }
                i -= 1
                j += 1
            }
            return true
        }
        func backtracking(_ row: Int) {
            if row == n {
                res.append(chessboard.map {
                    String($0)
                })
            }
            for col in 0 ..< n {
                guard isValid(row, col) else {
                    continue
                }
                chessboard[row][col] = "Q"
                backtracking(row + 1)
                chessboard[row][col] = "."
            }
        }
        backtracking(0)
        return res
    }
}
```

