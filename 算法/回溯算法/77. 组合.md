# 77. 组合

https://leetcode.cn/problems/combinations/

`medium`

**<font color=red>回溯算法，注意返回</font>**

## 题目描述

> 给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。
>
> 你可以按 **任何顺序** 返回答案。
>
>  
>
> **示例 1：**
>
> ```
> 输入：n = 4, k = 2
> 输出：
> [
>   [2,4],
>   [3,4],
>   [2,3],
>   [1,2],
>   [1,3],
>   [1,4],
> ]
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 1, k = 1
> 输出：[[1]]
> ```



## Core

- 回溯算法
- 注意边界条件，当start > n 时，应该停止



## Code

时间复杂度分析：

- 主要的时间消耗在回溯过程中的循环和递归上。
- 外层循环的迭代次数是 `n`，因为 `start` 从 1 遍历到 `n`。
- 对于每次迭代，内层循环的迭代次数也是 `n`，因为 `num` 从 `start` 遍历到 `n`。
- 在每次递归调用中，`backtrack` 函数将被调用一次，并且它的递归深度为 `k`。
- 所以，总体的时间复杂度为 O(n^k)，其中 `n` 是范围的大小，`k` 是组合的长度。

空间复杂度分析：

- 主要的空间消耗在 `res` 和 `path` 这两个变量上，以及递归调用栈上。
- `res` 是存储所有组合的列表，所以它的空间复杂度取决于最终生成的组合数量。在最坏情况下，会有 `C(n, k)` 个组合，其中 `C(n, k)` 表示从 `n` 个元素中选取 `k` 个的组合数，即 O(n^k)。
- `path` 是用于记录当前组合的临时路径，其最大长度为 `k`，所以它的空间复杂度为 O(k)。

```swift
class Solution {
    func combine(_ n: Int, _ k: Int) -> [[Int]] {
        var res = [[Int]]()
        var path = [Int]()
        backtrack(1, n, k, &path, &res)
        return res
    }
    private func backtrack(_ start: Int, _ n: Int, _ k: Int, _ path: inout [Int], _ res: inout [[Int]]) {
        if path.count == k {
            res.append(path)
            return
        }
        if start > n {
            return
        }
        for num in start ... n {  
          // 剪枝优化：n -> n - (k - path.count) + 1
            path.append(num)
            backtrack(num + 1, n, k, &path, &res)
            path.removeLast()
        }
    }
    
}
```

