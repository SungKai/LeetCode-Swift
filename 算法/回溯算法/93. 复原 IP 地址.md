# 93. 复原 IP 地址

https://leetcode.cn/problems/restore-ip-addresses/

`medium`

**<font color=red>切割:回溯算法,Character到Int 判断是否在数字范围内</font>**

## 题目描述

> **有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。
>
> - 例如：`"0.1.2.201"` 和` "192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。
>
> 给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "25525511135"
> 输出：["255.255.11.135","255.255.111.35"]
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "0000"
> 输出：["0.0.0.0"]
> ```
>
> **示例 3：**
>
> ```
> 输入：s = "101023"
> 输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
> ```



## Core

- 切割：回溯算法
- Character到Int 判断是否在数字范围内

## Code

**时间复杂度分析：**

1. `isValid` 函数中的循环迭代的次数取决于区间的长度，而区间的长度最大为 `s.count`，因此 `isValid` 函数的时间复杂度为 O(n)，其中 n 是字符串的长度。
2. `backtracing` 函数的主要部分是一个嵌套循环，其中外层循环从 `startIndex` 到字符串末尾，内层循环也从 `startIndex` 到字符串末尾。对于每个子串，`isValid` 函数的调用时间复杂度为 O(n)。因此，每个子串的处理时间复杂度为 O(n^2)。在最坏情况下，需要检查的子串数量可能达到 O(n^2)。因此，总体时间复杂度为 O(n^4)，其中 n 是字符串的长度。

**空间复杂度分析：**

1. `s` 数组占用 O(n) 的额外空间，其中 n 是字符串的长度。
2. `res` 数组存储所有恢复后的 IP 地址，其空间取决于恢复后的 IP 地址数量和每个 IP 地址的长度。在最坏情况下，可能有 O(2^n) 个 IP 地址，每个 IP 地址的长度取决于原始字符串的长度。因此，`res` 数组的总空间复杂度为 O(n * 2^n)。
3. 在递归过程中，使用的额外空间是常数级别的，因此不会对空间复杂度产生显著影响。

综上所述，总体空间复杂度为 O(n * 2^n)，时间复杂度为 O(n^4)。

```swift
class Solution {
    // 判断区间段是否合法
    func isValid(_ s: [Character], _ start: Int, _ end: Int) -> Bool {
        guard start <= end, start >= 0, end < s.count else {
            return false
        }
        if start != end, s[start] == "0" {
            return false
        }
        var num = 0
        for i in start ... end {
            let c = s[i]
            guard c >= "0", c <= "9" else {
                return false
            }
            let value = c.asciiValue! - ("0" as Character).asciiValue! 
            num = num * 10 + Int(value)
            guard num <= 255 else {
                return false
            }
        }
        return true
    }
    func restoreIpAddresses(_ s: String) -> [String] {
        var res = [String]()
        var s = Array(s)
        func backtracing(_ startIndex: Int, _ pointCount: Int) {
            if pointCount == 3 {
                if isValid(s, startIndex, s.count - 1) {
                    res.append(String(s))
                }
                return 
            }
            guard startIndex < s.count else {
                return 
            }
            for i in startIndex ..< s.count {
                if isValid(s, startIndex, i) {
                    s.insert(".", at: i + 1)
                    backtracing(i + 2, pointCount + 1)
                    s.remove(at: i + 1)
                } else {
                    break
                }
            }
        }
        backtracing(0, 0)
        return res
    }   
}
```

