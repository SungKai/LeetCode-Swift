## 47. 全排列 II

https://leetcode.cn/problems/permutations-ii/

`medium`

**<font color=red>排列，需要去重</font>**

## 题目描述

> 给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,1,2]
> 输出：
> [[1,1,2],
>  [1,2,1],
>  [2,1,1]]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```



## Core

- 需要去重



## Code

O(n!), O(n)

```swift
class Solution {
    func permuteUnique(_ nums: [Int]) -> [[Int]] {
        let nums = nums.sorted()
        var res = [[Int]]()
        var path = [Int]()
        var used = [Bool](repeating: false, count: nums.count)
        func backtracking() {
            if path.count == nums.count {
                res.append(path)
                return 
            }
            for i in 0 ..< nums.count {
                if i > 0, nums[i] == nums[i - 1], !used[i - 1] {
                    continue
                }
                if used[i] {
                    continue
                }
                used[i] = true
                path.append(nums[i])
                backtracking()
                path.removeLast()
                used[i] = false
            }
        }
        backtracking()
        return res
    }
}
```

