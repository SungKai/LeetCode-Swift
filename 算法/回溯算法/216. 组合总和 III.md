# 216. 组合总和 III

https://leetcode.cn/problems/combination-sum-iii/

`medium`

**<font color=red>回溯算法，注意返回</font>**

## 题目描述

> 找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：
>
> - 只使用数字1到9
> - 每个数字 **最多使用一次** 
>
> 返回 *所有可能的有效组合的列表* 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。
>
>  
>
> **示例 1:**
>
> ```
> 输入: k = 3, n = 7
> 输出: [[1,2,4]]
> 解释:
> 1 + 2 + 4 = 7
> 没有其他符合的组合了。
> ```
>
> **示例 2:**
>
> ```
> 输入: k = 3, n = 9
> 输出: [[1,2,6], [1,3,5], [2,3,4]]
> 解释:
> 1 + 2 + 6 = 9
> 1 + 3 + 5 = 9
> 2 + 3 + 4 = 9
> 没有其他符合的组合了。
> ```

## Core

- 回溯算法，注意返回条件
- 与[77. 组合](https://leetcode.cn/problems/combinations/)相似，但是for 的终点已经确定，是9，返回条件要加上sum = targetNum



## Code

O(9^n)，O(n)

n = count

```swift
class Solution {
    func combinationSum3(_ count: Int, _ targetSum: Int) -> [[Int]] {
        var result = [[Int]]()
        var path = [Int]()
        func backtracking(sum: Int, start: Int) {
            // 剪枝
            if sum > targetSum { return }
            // 终止条件
            if path.count == count {
                if sum == targetSum {
                    result.append(path)
                }
                return
            }

            // 单层逻辑
            let end = 9
            guard start <= end else { return }
            for i in start ... end {
                path.append(i) // 处理
                backtracking(sum: sum + i, start: i + 1)
                path.removeLast() // 回溯
            }
        }
        backtracking(sum: 0, start: 1)
        return result
    }
}
```

