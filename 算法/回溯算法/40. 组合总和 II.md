# 40. 组合总和 II

https://leetcode.cn/problems/combination-sum-ii/

`medium`

**<font color=red>组合回溯</font>**

## 题目描述

> 给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。
>
> `candidates` 中的每个数字在每个组合中只能使用 **一次** 。
>
> **注意：**解集不能包含重复的组合。 
>
>  
>
> **示例 1:**
>
> ```
> 输入: candidates = [10,1,2,7,6,1,5], target = 8,
> 输出:
> [
> [1,1,6],
> [1,2,5],
> [1,7],
> [2,6]
> ]
> ```
>
> **示例 2:**
>
> ```
> 输入: candidates = [2,5,2,1,2], target = 5,
> 输出:
> [
> [1,2,2],
> [5]
> ]
> ```



## Core

- 组合回溯

## Code

时间复杂度分析： 回溯算法的时间复杂度通常很难精确地计算，因为它涉及到搜索所有可能的组合。在最坏情况下，每个元素都被考虑了多次，但是仍然会因为在某些情况下提前终止而有所缩减。因此，时间复杂度可以近似地看作是指数级的，大致为 O(2^n)，其中 n 是输入数组 `candidates` 的长度。

空间复杂度分析：

1. `res` 数组用于存储所有可能的组合，它的空间复杂度取决于最终结果的数量，最坏情况下可能是指数级的，因此为 O(2^n)。
2. `path` 数组用于暂存当前路径的元素，在递归过程中会动态变化，最多会包含 `candidates` 数组的元素个数，因此空间复杂度为 O(n)。

空间复杂度是 O(2^n + n)

```swift
class Solution {
    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {
        let candidates = candidates.sorted()
        var res = [[Int]]()
        var path = [Int]()
        func backtracing(_ sum: Int, _ startIndex: Int) {
            if sum == target {
                res.append(path)
                return 
            }
            let end = candidates.count
            guard startIndex < end else {
                return
            }
            for i in startIndex ..< end {
                if i > startIndex, candidates[i] == candidates[i - 1] {
                    continue
                }
                let sum = sum + candidates[i]
                if sum > target {
                    return
                }
                path.append(candidates[i])
                backtracing(sum, i + 1)
                path.removeLast()
            }
        }
        backtracing(0, 0)
        return res
    }
}
```

