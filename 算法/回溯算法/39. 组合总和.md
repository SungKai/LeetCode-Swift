# 39. 组合总和

https://leetcode.cn/problems/combination-sum/

`medium`

**<font color=red>组合回溯</font>**

## 题目描述

> 给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。
>
> `candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
>
> 对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。
>
>  
>
> **示例 1：**
>
> ```
> 输入：candidates = [2,3,6,7], target = 7
> 输出：[[2,2,3],[7]]
> 解释：
> 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
> 7 也是一个候选， 7 = 7 。
> 仅有这两种组合。
> ```
>
> **示例 2：**
>
> ```
> 输入: candidates = [2,3,5], target = 8
> 输出: [[2,2,2,2],[2,3,3],[3,5]]
> ```



## Core

- 组合回溯

## Code

时间复杂度分析： 回溯算法的时间复杂度通常很难精确地计算，因为它涉及到搜索所有可能的组合。在最坏情况下，每个元素都被考虑了多次，但是仍然会因为在某些情况下提前终止而有所缩减。因此，时间复杂度可以近似地看作是指数级的，大致为 O(2^n)，其中 n 是输入数组 `candidates` 的长度。

空间复杂度分析：

1. `res` 数组用于存储所有可能的组合，它的空间复杂度取决于最终结果的数量，最坏情况下可能是指数级的，因此为 O(2^n)。
2. `path` 数组用于暂存当前路径的元素，在递归过程中会动态变化，最多会包含 `candidates` 数组的元素个数，因此空间复杂度为 O(n)。

空间复杂度是 O(2^n + n)

```swift
class Solution {
    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {
        var res = [[Int]]()
        var path = [Int]()
        func backtracking(_ sum: Int, _ startIndex: Int) {
            if sum == target {
                res.append(path)
                return 
            }
            let end = candidates.count
            guard startIndex < end else {
                return 
            }
            for i in startIndex ..< end {
                // 使用局部变量隐藏回溯
                let sum = sum + candidates[i]
                if sum > target {
                    continue
                }
                path.append(candidates[i])
                backtracking(sum, i)
                path.removeLast()
            }
        }
        backtracking(0, 0)
        return res
    }
}
```

