# 数据结构与算法性能分析

**数据结构**是计算机里储存，组织数据的方式

原则：**一个良好的数据结构，应该是在占用较少的时间，空间资源的情况下，保证各种程序的正常运行**

正确的数据结构的选择可以提高算法的效率

## 算法性能分析

### 时间复杂度

指最暴力的解法

<img src="/Users/songjiaming/Documents/Typora/leetcode-Array/Screen Shot 2022-03-06 at 9.01.52 PM.png" alt="Screen Shot 2022-03-06 at 9.01.52 PM" style="zoom:50%;" />

不一定O(logn)是最好的，在数据小的时候，O(n^2)反而快

**我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大。基于这样的事实，给出的算法时间复杂的的一个排行如下所示：**

**<font color=red>O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(nlogn)线性对数阶 < O(n^2)平方阶 < O(n^3)立方阶 < O(2^n)指数阶</font>**



- 一行“普通的”代码所需要执行一次--->复杂度O(1)
- 那么例如for循环这样的结构虽然只占一行，但是实际上要执行多次（n次）--->复杂度O(n),
- 有3个并列 for：O(3); 
- 在这个时候，如果是for套娃

```c
// 1.“普通的”代码--->复杂度O(1)
int a = 0;  //执行一次
int b = 0;  //执行一次
// 2.这行代码是一个for循环--->复杂度O(n)
for (int i = 0; i < numsSize; i++){
  // 3.套娃：--->复杂度O(n^2)
  for (int j = 0; j < i; j++){
    printf("执行");  //执行n^2次
  }
}
// 4.查找判断类型--->复杂度O(logn)（二分法）
int i = 1;
while (i < n){
  i = i * 2;
}
```

二分查找：

每次比较可以将**查找区间缩小一半**（每次不断除以2），因此查找区间的长度会不断缩小，最终会缩小到1或0。因此，在最坏情况下，如果要查找的元素不存在于有序数组中，二分查找需要进行log2(n)次比较，其中n是数组A中元素的个数。因此，二分查找的时间复杂度是O(log n)。


$$
2^x = n
$$

$$
x = logn
$$

```c
// 5.线性对数阶：O(nlogn)是很常见的时间复杂度，像快速排序、归并排序的时间复杂度都是 O(nlogn)。
```

#### O(logn)中的log是以什么为底？

事实上，logn就是**忽略底数**的描述。

这要归于时间复杂度都是**省略常数项系数**的原因。
$$
\log_{2}{n} = \log_{2}10 \times \log_{10}n
O(\log_{2}{n}) = \log_{2}10 \times \log_{10}n
$$

$$
O(\log_{i}{n}) = O(\log_{i}j \times \log_{j}n)
$$

其中，
$$
\log_{i}j
$$
是一个常数，所以，算法的时间复杂度可以等于
$$
O(log_{j}n)
$$
进一步可以等于
$$
O(logn)
$$


### 空间复杂度

是对一个算法在运行过程中占用**内存空间**大小的量度，记做 `S(n) = O(f(n))`。

利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先估计。

例子：

空间复杂度为`O(1)` 的代码：

```c
int j = 0;
for (int i = 0; i < n; i++) {
    j++;
}
```

可以看出，随着n 的变化，所需开辟的内存空间并不会随着n的变化而变化。即此算法空间复杂度为一个常量，所以为O(1)。



空间复杂度为`O(n)` 的代码：

```c
int a[n];
for (int i = 0; i < n; i++) {
    a[i] = i;
}
```

可以看出，**消耗空间和输入参数n 保持线性增长**。

我们定义了一个数组出来，这个数组占用的大小为n，虽然有一个for 循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看**第一行**即可，随着n的增大，开辟的内存大小呈线性增长，即 O(n)。

除此之外，当出现递归的时候，**会出现空间复杂度为logn的情况**。

即每次递归都把问题规模缩小为原来的一半。例如二分查找和归并排序等算法就具有这种特点。在这些算法中，每个节点所占用的空间也是常数级别的。

具体而言，当一个递归算法每次递归都把问题规模缩小为原来的一半时，递归树的深度就是O(log n)。例如，在二分查找算法中，每次将问题规模减半，递归深度为log2(n)；在归并排序算法中，每次将数组分成两半，递归深度也为log2(n)。同时，每个节点所占用的空间是常数级别的，因此总的空间复杂度就是O(log n)。
