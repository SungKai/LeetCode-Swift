# 哈希表 Hash table

哈希表是根据关键码的值直接进行访问的数据结构

（数组就是一张哈希表，关键码就是数组的索引下标）

**一般哈希表都是用来快速判断一个元素是否出现集合里。**要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。

## 哈希函数

把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。

通过hashCode 把名字转化为数值，通过特定编码的方式，将其他数据格式转化为不同的数值。

![哈希表2](https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423484818.png)

此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。如果学生数大于哈希表大小，就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置，就会出现**哈希碰撞**

## 哈希碰撞

![哈希表3](https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423494884.png)

一般有两种解决方法：拉链法和线性探测法

### 拉链法

使发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了。

![哈希表4](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235015226.png)

其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。



### 线性探测法

数据规模是dataSize， 哈希表的大小为tableSize

使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。

例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。

![哈希表5](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235109950.png)







## 哈希表常见的结构

### 字典（Dictionary）

字典是一种存储键值对的数据结构，其中每个键都必须是唯一的。在内部，字典使用哈希表来实现高效的键值查找。

```swift
var studentScores = ["Alice": 95, "Bob": 87, "Charlie": 92]
studentScores["David"] = 78  // 添加键值对
let aliceScore = studentScores["Alice"]  // 查询值
studentScores["Bob"] = nil  // 删除键值对

```

### 集合（Set）

集合是一种存储唯一值的数据结构，与字典类似，它也使用哈希表来实现。集合用于存储一组无序、不重复的元素，这对于需要快速判断元素是否存在或者需要消除重复元素的场景非常有用。

```swift
var uniqueNumbers: Set<Int> = [1, 2, 3, 4, 5]
uniqueNumbers.insert(6)
let containsThree = uniqueNumbers.contains(3)
uniqueNumbers.remove(4)
```



哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的空间