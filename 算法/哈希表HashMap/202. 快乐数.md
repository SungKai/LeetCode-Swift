# 202. 快乐数

https://leetcode.cn/problems/happy-number/

**<font color=red>Set<> 用于找不重复的元素</font>**



## 题目描述

> 编写一个算法来判断一个数 `n` 是不是快乐数。
>
> **「快乐数」** 定义为：
>
> - 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
> - 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
> - 如果这个过程 **结果为** 1，那么这个数就是快乐数。
>
> 如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：n = 19
> 输出：true
> 解释：
> 12 + 92 = 82
> 82 + 22 = 68
> 62 + 82 = 100
> 12 + 02 + 02 = 1
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 2
> 输出：false
> ```



## Core

- 问题转化为遇到重复元素即stop：**Set<> 用于找不重复的元素**

## Code

时间复杂度分析：

1. 外部循环会在两种情况下终止：要么 `n` 变为 1，要么 `n` 重复出现。在最坏情况下，我们可能需要进行 O(n) 次循环，其中 n 是输入的数值大小（在严格数学上，可能略微少于 n 次，因为我们不会直接重复上一次的数字，但是在大 O 表示法中，这被视为线性时间复杂度）。
2. 内部循环用于计算数字的每位上的平方和。由于数字的位数是 log(n)（以 10 为底）的数量级，内部循环的时间复杂度是 O(log n)。

因此，总的时间复杂度可以近似地表示为 O(n * log n)。

空间复杂度分析：

1. 在内存中，我们使用了一个 `seenNumbers` 集合来存储已经出现过的数字。在最坏情况下，如果我们需要遍历所有可能的数字，集合的大小将达到 n。因此，空间复杂度是 O(n)。
2. 另外，除了输入和常量级变量之外，我们没有使用太多其他的内存，所以其他部分的空间复杂度可以被忽略。

综合起来，总的空间复杂度可以近似地表示为 O(n)。

```swift
class Solution {
    func isHappy(_ n: Int) -> Bool {
        var n = n
        var seenNumbers = Set<Int>()
        while n != 1, !seenNumbers.contains(n) {  // 要么得到 1，要么进入无限循环
            seenNumbers.insert(n)
            var sum = 0
            var num = n
            while num > 0 {
                let digit = num % 10
                sum += digit * digit
                num /= 10
            }
            n = sum
        }
        return n == 1
    }
}
```

