# 190. 颠倒二进制位

https://leetcode.cn/problems/reverse-bits/

**<font color=red>简单的位运算：利用左移右移</font>**

## 题目描述

> 颠倒给定的 32 位无符号整数的二进制位。
>
> **提示：**
>
> - 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
> - 在 Java 中，编译器使用[二进制补码](https://baike.baidu.com/item/二进制补码/5295284)记法来表示有符号整数。因此，在 **示例 2** 中，输入表示有符号整数 `-3`，输出表示有符号整数 `-1073741825`。
>
>  
>
> **示例 1：**
>
> ```
> 输入：n = 00000010100101000001111010011100
> 输出：964176192 (00111001011110000010100101000000)
> 解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
>      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 11111111111111111111111111111101
> 输出：3221225471 (10111111111111111111111111111111)
> 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
>      因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
> ```

## Core

- 简单的位运算：利用左移右移
- 从输入的整数的最低位开始，逐位获取并将其添加到结果中，同时将结果向左移动一位。

## Code

算法的时间复杂度是O(32)，因为需要迭代32次，而空间复杂度是O(1)，因为只使用了常量额外的空间。

```swift
class Solution {
    func reverseBits(_ n: Int) -> Int {
        var result: UInt32 = 0
    var num = n
    var power = 31 // 因为是32位整数，从最高位到最低位需要32次迭代
    
    while num > 0 {
        let bit = num & 1 // 获取最低位的值
        result += UInt32(bit) << power // 将最低位添加到结果
        num >>= 1 // 右移一位，处理下一位
        power -= 1 // 更新指数
    }
    
    return Int(result)
    }
}
```

