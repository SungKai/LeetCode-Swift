# 338. 比特位计数

https://leetcode.cn/problems/counting-bits/

**<font color=red>位运算，动态规划</font>**

## 题目描述

> 给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。
>
>  
>
> **示例 1：**
>
> ```
> 输入：n = 2
> 输出：[0,1,1]
> 解释：
> 0 --> 0
> 1 --> 1
> 2 --> 10
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 5
> 输出：[0,1,1,2,1,2]
> 解释：
> 0 --> 0
> 1 --> 1
> 2 --> 10
> 3 --> 11
> 4 --> 100
> 5 --> 101
> ```

## Core

- 本题可以利用动态规划和位运算进行快速的求解。定义一个数组 dp，其中 dpll 表示数字i 的二进制含有1的个数。对于第i个数字，如果它二进制的最后一位为1，那么它含有1的个数则为 dpi-1]+1；如果它二进制的最后一位为0，那么它含有1的个数和其算术右移结果相同，即 dpli>>1]。

## Code

O(n), O(n)

```swift
class Solution {
    func countBits(_ n: Int) -> [Int] {
        var dp = [Int](repeating: 0, count: n + 1)
        for i in 0 ... n {
            if i & 1 == 1 {
                dp[i] = dp[i - 1] + 1
            } else {
                dp[i] = dp[i >> 1]
            }
            // dp[i] = i & 1  == 1 ? dp[i - 1] + 1 : dp[i >> 1]
        }
        return dp
    }
}
```

